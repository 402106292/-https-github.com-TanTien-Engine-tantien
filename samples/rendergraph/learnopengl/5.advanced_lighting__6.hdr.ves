var node0 = Clear()
_editor.add_node(node0, -68.183024411294, 1013.7392585871)

node0.masks = [ "depth" ]
node0.values = { "color" : [ 0.10000000149012, 0.10000000149012, 0.10000000149012, 1 ] }

var node1 = Draw()
_editor.add_node(node1, 233.21917737572, 673.1720833414)

node1.set_prim_type("triangles")
node1.render_state = { "depth_test" : true, "depth_func" : "less", "cull" : "disable" }

var node2 = Shader()
_editor.add_node(node2, -70.033484051636, 194.72322382351)

node2.vs = "
#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;

out VS_OUT {
    vec3 FragPos;
    vec3 Normal;
    vec2 TexCoords;
} vs_out;

uniform UBO
{
	mat4 projection;
	mat4 view;
	mat4 model;

	bool inverse_normals;	
};

void main()
{
    vs_out.FragPos = vec3(model * vec4(aPos, 1.0));   
    vs_out.TexCoords = aTexCoords;
    
    vec3 n = inverse_normals ? -aNormal : aNormal;
    
    mat3 normalMatrix = transpose(inverse(mat3(model)));
    vs_out.Normal = normalize(normalMatrix * n);
    
    gl_Position = projection * view * model * vec4(aPos, 1.0);
}
"
node2.fs = "
#version 330 core
out vec4 FragColor;

in VS_OUT {
    vec3 FragPos;
    vec3 Normal;
    vec2 TexCoords;
} fs_in;

uniform sampler2D diffuseTexture;

struct Light {
    vec3 Position;
    vec3 Color;
};

uniform UBO
{
	Light lights[4];
	vec3 viewPos;	
};

void main()
{           
    vec3 color = texture(diffuseTexture, fs_in.TexCoords).rgb;
    vec3 normal = normalize(fs_in.Normal);
    // ambient
    vec3 ambient = 0.0 * color;
    // lighting
    vec3 lighting = vec3(0.0);
    for(int i = 0; i < 16; i++)
    {
        // diffuse
        vec3 lightDir = normalize(lights[i].Position - fs_in.FragPos);
        float diff = max(dot(lightDir, normal), 0.0);
        vec3 diffuse = lights[i].Color * diff * color;      
        vec3 result = diffuse;        
        // attenuation (use quadratic as we have gamma correction)
        float distance = length(fs_in.FragPos - lights[i].Position);
        result *= 1.0 / (distance * distance);
        lighting += result;
                
    }
    FragColor = vec4(ambient + lighting, 1.0);
}
"
node2.execute()
node2.set_uniform("inverse_normals", [ 1.0037198066711 ])
node2.set_uniform("lights[0].Position", [ 0, 0, 49.5 ])
node2.set_uniform("lights[0].Color", [ 200, 200, 200 ])
node2.set_uniform("lights[1].Position", [ -1.4, -1.9, 9 ])
node2.set_uniform("lights[1].Color", [ 0.10000000149012, 0, 0 ])
node2.set_uniform("lights[2].Position", [ 0, -1.8, 4 ])
node2.set_uniform("lights[2].Color", [ 0, 0, 0.20000000298023 ])
node2.set_uniform("lights[3].Position", [ 0.80000001192093, -1.7, 6 ])
node2.set_uniform("lights[3].Color", [ 0, 0.10000000149012, 0 ])

var node3 = PrimitiveShape()
_editor.add_node(node3, 68.722433333658, 651.7188029569)

node3.type = "cube"
node3.layout = [ "position", "normal", "texture" ]

var node4 = Perspective()
_editor.add_node(node4, -290.78383194422, 843.91156899396)

node4.fovy = 45
node4.aspect = 0
node4.znear = 0.10000000149012
node4.zfar = 100

var node5 = Camera3D()
_editor.add_node(node5, -450.10066272342, 719.12246846686)

node5.position.set(0, 0, 3)
node5.yaw = 96.1
node5.pitch = -6.3
node5.zoom = 45
node5.update_camera_vectors()

var node6 = Texture()
_editor.add_node(node6, -287.61171236857, 362.81003968489)
node6.gamma_correction = true
node6.init_texture("resources/textures/wood.png")
node6.set_sampler("linear repeat")
var node7 = Matrix()
_editor.add_node(node7, -637.61472706782, 602.44510982856)

var node8 = Translate()
_editor.add_node(node8, -330.28961903423, 566.2941876913)

node8.dx = 0
node8.dy = 0
node8.dz = 25

var node9 = Scale()
_editor.add_node(node9, -482.33805409467, 573.95135236664)

node9.sx = 2.5
node9.sy = 2.5
node9.sz = 27.5

var node10 = Pass()
_editor.add_node(node10, 497.59578419333, 628.42354250067)

var node11 = RenderTarget()
_editor.add_node(node11, 341.40907932805, 421.02879895375)

node11.width = 1024
node11.height = 1024

var node12 = Texture()
_editor.add_node(node12, 135.2051316, 482.2948684)
node12.gamma_correction = false
node12.init_texture(1024, 1024, "rgb")
node12.set_sampler("linear repeat")
var node13 = Clear()
_editor.add_node(node13, 611.3767464907, 244.47903657091)

node13.masks = [ "color", "depth" ]
node13.values = { "color" : [ 0.10000000149012, 0.10000000149012, 0.10000000149012, 1 ] }

var node14 = Draw()
_editor.add_node(node14, 798.2275241, 126.0293269)

node14.set_prim_type("tri_strip")
node14.render_state = { "depth_test" : false, "depth_func" : "less", "cull" : "disable" }

var node15 = Shader()
_editor.add_node(node15, 547.78585808094, 58.012725685842)

node15.vs = "
#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec2 aTexCoords;

out vec2 TexCoords;

void main()
{
    TexCoords = aTexCoords;
    gl_Position = vec4(aPos, 1.0);
}
"
node15.fs = "
#version 330 core
out vec4 FragColor;

in vec2 TexCoords;

uniform sampler2D hdrBuffer;

uniform UBO
{
    bool hdr;
    float exposure;    
};

void main()
{             
    const float gamma = 2.2;
    vec3 hdrColor = texture(hdrBuffer, TexCoords).rgb;
    if(hdr)
    {
        // reinhard
        // vec3 result = hdrColor / (hdrColor + vec3(1.0));
        // exposure
        vec3 result = vec3(1.0) - exp(-hdrColor * exposure);
        // also gamma correct while we're at it       
        result = pow(result, vec3(1.0 / gamma));
        FragColor = vec4(result, 1.0);
    }
    else
    {
        vec3 result = pow(hdrColor, vec3(1.0 / gamma));
        FragColor = vec4(result, 1.0);
    }
}
"
node15.execute()
node15.set_uniform("hdr", [ 1 ])
node15.set_uniform("exposure", [ 4 ])

var node16 = PrimitiveShape()
_editor.add_node(node16, 551.92925727603, -115.02215628678)

node16.type = "quad"
node16.layout = [ "position", "texture" ]

Blueprint.connect(node0.exports[0], node1.imports[0])
Blueprint.connect(node1.exports[0], node10.imports[0])
Blueprint.connect(node2.exports[0], node1.imports[1])
Blueprint.connect(node3.exports[0], node1.imports[2])
Blueprint.connect(node4.exports[0], node2.imports[0])
Blueprint.connect(node5.exports[0], node2.imports[1])
Blueprint.connect(node5.exports[1], node4.imports[0])
Blueprint.connect(node5.exports[3], node2.imports[12])
Blueprint.connect(node6.exports[0], node2.imports[13])
Blueprint.connect(node7.exports[0], node9.imports[0])
Blueprint.connect(node8.exports[0], node2.imports[2])
Blueprint.connect(node9.exports[0], node8.imports[0])
Blueprint.connect(node11.exports[0], node10.imports[1])
Blueprint.connect(node12.exports[0], node11.imports[0])
Blueprint.connect(node12.exports[0], node15.imports[2])
Blueprint.connect(node13.exports[0], node14.imports[0])
Blueprint.connect(node15.exports[0], node14.imports[1])
Blueprint.connect(node16.exports[0], node14.imports[2])
