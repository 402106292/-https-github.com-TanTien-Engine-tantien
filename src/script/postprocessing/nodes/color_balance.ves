import "blueprint.node" for Node
import "blueprint.node_function" for NodeFunction
import "maths.vector" for Vector2, Vector3

var CODE = "
// from https://github.com/prod80/prod80-ReShade-Repository

uniform __UBO__
{
    bool  preserve_luma;        // Preserve Luminosity
    int   separation_mode;      // Luma Separation Mode

    float s_RedShift;           // Shadows: Cyan <--> Red
    float s_GreenShift;         // Shadows: Magenta <--> Green
    float s_BlueShift;          // Shadows: Yellow <--> Blue

    float m_RedShift;           // Midtones: Cyan <--> Red
    float m_GreenShift;         // Midtones: Magenta <--> Green
    float m_BlueShift;          // Midtones: Yellow <--> Blue

    float h_RedShift;           // Highlights: Cyan <--> Red
    float h_GreenShift;         // Highlights: Magenta <--> Green
    float h_BlueShift;          // Highlights: Yellow <--> Blue
};

#define ES_RGB   vec3( 1.0 - vec3( 0.299, 0.587, 0.114 ))
#define ES_CMY   vec3( dot( ES_RGB.yz, vec2(0.5) ), dot( ES_RGB.xz, vec2(0.5) ), dot( ES_RGB.xy, vec2(0.5) ))

vec3 curve( vec3 x )
{
    return x * x * ( 3.0f - 2.0f * x );
}

vec3 color_balance( vec3 c, vec3 shadows, vec3 midtones, vec3 highlights )
{
    // For highlights
    float luma = dot( c.xyz, vec3( 0.333333f, 0.333334f, 0.333333f ));
        
    // Determine the distribution curves between shadows, midtones, and highlights
    vec3 dist_s; vec3 dist_h;

    switch( separation_mode )
    {
        /*
        Clear cutoff between shadows and highlights
        Maximizes precision at the loss of harsher transitions between contrasts
        Curves look like:

        Shadows                Highlights             Midtones
        ‾‾‾—_                                _—‾‾‾         _——‾‾‾——_
                ‾‾——__________    __________——‾‾         ___—‾         ‾—___
        0.0.....0.5.....1.0    0.0.....0.5.....1.0    0.0.....0.5.....1.0
            
        */
        case 0:
        {
            dist_s.xyz  = curve( max( 1.0f - c.xyz * 2.0f, 0.0f ));
            dist_h.xyz  = curve( max(( c.xyz - 0.5f ) * 2.0f, 0.0f ));
        } break;

        /*
        Higher degree of blending between individual curves
        F.e. shadows will still have a minimal weight all the way into highlight territory
        Ensures smoother transition areas between contrasts
        Curves look like:

        Shadows                Highlights             Midtones
        ‾‾‾—_                                _—‾‾‾          __---__
                ‾‾———————_____    _____———————‾‾         ___-‾‾       ‾‾-___
        0.0.....0.5.....1.0    0.0.....0.5.....1.0    0.0.....0.5.....1.0
            
        */
        case 1:
        {
            dist_s.xyz  = pow( 1.0f - c.xyz, vec3(4.0f) );
            dist_h.xyz  = pow( c.xyz, vec3(4.0f) );
        } break;
    }

    // Get luminosity offsets
    // One could omit this whole code part in case no luma should be preserved
    vec3 s_rgb = vec3(1.0f);
    vec3 m_rgb = vec3(1.0f);
    vec3 h_rgb = vec3(1.0f);

    if( preserve_luma )
    {
        s_rgb    = all(lessThan(vec3(0.0f), shadows))    ? ES_RGB * shadows      : ES_CMY * abs( shadows );
        m_rgb    = all(lessThan(vec3(0.0f), midtones))   ? ES_RGB * midtones     : ES_CMY * abs( midtones );
        h_rgb    = all(lessThan(vec3(0.0f), highlights)) ? ES_RGB * highlights   : ES_CMY * abs( highlights );
    }
    vec3 mids  = clamp( 1.0f - dist_s.xyz - dist_h.xyz, 0.0, 1.0 );
    vec3 highs = dist_h.xyz * ( highlights.xyz * h_rgb.xyz * ( 1.0f - luma ));
    vec3 newc  = c.xyz * ( dist_s.xyz * shadows.xyz * s_rgb.xyz + mids.xyz * midtones.xyz * m_rgb.xyz ) * ( 1.0f - c.xyz ) + highs.xyz;
    return clamp( c.xyz + newc.xyz, 0.0, 1.0 );
}

vec3 color_balance_pass(vec3 color)
{
    vec3 ret = clamp(color, 0.0, 1.0);
    ret = color_balance(ret.xyz, vec3( s_RedShift, s_GreenShift, s_BlueShift ), 
                                 vec3( m_RedShift, m_GreenShift, m_BlueShift ),
                                 vec3( h_RedShift, h_GreenShift, h_BlueShift ));
    return ret;
}

"

class ColorBalance is Node
{
	init() 
	{
		super.init(ColorBalance.name)

		this.node_func = NodeFunction(this, CODE, "color_balance_pass", [
            [ "preserve_luma", true ],
            [ "separation_mode", 0, { "integer" : true, "min" : 0, "max" : 1 } ],       // 0: Harsh Separation, 1: Smooth Separation
            [ "s_RedShift", 0.0, { "min" : -1.0, "max" : 1.0 } ],
            [ "s_GreenShift", 0.0, { "min" : -1.0, "max" : 1.0 } ],
            [ "s_BlueShift", 0.0, { "min" : -1.0, "max" : 1.0 } ],
            [ "m_RedShift", 0.0, { "min" : -1.0, "max" : 1.0 } ],
            [ "m_GreenShift", 0.0, { "min" : -1.0, "max" : 1.0 } ],
            [ "m_BlueShift", 0.0, { "min" : -1.0, "max" : 1.0 } ],
            [ "h_RedShift", 0.0, { "min" : -1.0, "max" : 1.0 } ],
            [ "h_GreenShift", 0.0, { "min" : -1.0, "max" : 1.0 } ],
            [ "h_BlueShift", 0.0, { "min" : -1.0, "max" : 1.0 } ],
        ])
	}
}