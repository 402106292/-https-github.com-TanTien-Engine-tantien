import "blueprint.node" for Node
import "blueprint.node_function" for NodeFunction
import "maths.vector" for Vector2, Vector3

var CODE = "
// from https://github.com/CeeJayDK/SweetFX
// CRT shader
// 
// Copyright (C) 2010-2012 cgwg, Themaister and DOLLS
// 
// This program is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 2 of the License, or (at your option)
// any later version.

uniform __UBO__
{
    vec2 screen_size;

    float amount;
    float resolution;
    float gamma;
    float monitor_gamma;
    float brightness;

    int scanline_intensity;
    bool scanline_gaussian;

    bool curvature;
    float curvature_radius;
    float corner_size;
    float viewer_distance;
    vec2 angle;
    
    float overscan;
    bool oversample;
};

// Comment the next line to disable interpolation in linear gamma (and gain speed).
//#define LINEAR_PROCESSING

#define CeeJay_aspect vec2(1.0, 0.75)

// A bunch of useful values we'll need in the fragment shader.
#define sinangle sin(angle)
#define cosangle cos(angle)
#define stretch maxscale()

// Macros.
#define FIX(c) max(abs(c), 1e-5);

#ifndef PI
  #define PI 3.1415927
#endif

// The size of one texel, in texture-coordinates.
#define coone 1.0 / rubyTextureSize

#define mod_factor texcoord.x * rubyTextureSize.x * rubyOutputSize.x / rubyInputSize.x

#ifdef LINEAR_PROCESSING
    #define TEX2D(c) pow(texture(tex, (c)), gamma)
#else
    #define TEX2D(c) texture(tex, (c))
#endif

float intersect(vec2 xy)
{
    float A = dot(xy,xy) + (viewer_distance * viewer_distance);
    float B = 2.0 * (curvature_radius * (dot(xy, sinangle) - viewer_distance * cosangle.x * cosangle.y) - viewer_distance * viewer_distance);
    float C = viewer_distance * viewer_distance + 2.0 * curvature_radius * viewer_distance * cosangle.x * cosangle.y; //all constants
    return (-B - sqrt(B * B -4.0 * A * C)) / (2.0 * A);
}

vec2 bkwtrans(vec2 xy)
{
    float c = intersect(xy);
    vec2 _point = vec2(c, c) * xy;
    _point -= vec2(-curvature_radius, -curvature_radius) * sinangle;
    _point /= vec2(curvature_radius, curvature_radius);
    vec2 tang = sinangle / cosangle;
    vec2 poc = _point / cosangle;
    float A = dot(tang, tang) + 1.0;
    float B = -2.0 * dot(poc, tang);
    float C = dot(poc, poc) - 1.0;
    float a = (-B + sqrt(B * B -4.0 * A * C)) / (2.0 * A);
    vec2 uv = (_point - a * sinangle) / cosangle;
    float r = curvature_radius * acos(a);
    return uv * r / sin(r / curvature_radius);
}
vec2 fwtrans(vec2 uv)
{
    float r = FIX(sqrt(dot(uv, uv)));
    uv *= sin(r / curvature_radius) / r;
    float x = 1.0 - cos(r / curvature_radius);
    float D = viewer_distance / curvature_radius + x * cosangle.x * cosangle.y + dot(uv, sinangle);
    return viewer_distance * (uv * cosangle - x * sinangle) / D;
}

vec3 maxscale()
{
    vec2 c = bkwtrans(-curvature_radius * sinangle / (1.0 + curvature_radius / viewer_distance * cosangle.x * cosangle.y));
    vec2 a = vec2(0.5, 0.5) * CeeJay_aspect;
    vec2 lo = vec2(fwtrans(vec2(-a.x, c.y)).x, fwtrans(vec2(c.x,-a.y)).y) / CeeJay_aspect;
    vec2 hi = vec2(fwtrans(vec2(+a.x, c.y)).x, fwtrans(vec2(c.x, +a.y)).y) / CeeJay_aspect;
    return vec3((hi + lo) * CeeJay_aspect * 0.5, max(hi.x - lo.x, hi.y - lo.y));
}

vec2 transform(vec2 coord, vec2 textureSize, vec2 inputSize)
{
    coord *= textureSize / inputSize;
    coord = (coord - 0.5) * CeeJay_aspect * stretch.z + stretch.xy;
    return (bkwtrans(coord) / vec2(overscan, overscan) / CeeJay_aspect + 0.5) * inputSize / textureSize;
}

float corner(vec2 coord, vec2 textureSize, vec2 inputSize)
{
    coord *= textureSize / inputSize;
    coord = (coord - 0.5) * vec2(overscan, overscan) + 0.5;
    coord = min(coord, 1.0 - coord) * CeeJay_aspect;
    vec2 cdist = vec2(corner_size, corner_size);
    coord = (cdist - min(coord, cdist));
    float dist = sqrt(dot(coord, coord));
    return clamp((cdist.x-dist) * 1000.0, 0.0, 1.0);
}

// Calculate the influence of a scanline on the current pixel.
//
// 'distance' is the distance in texture coordinates from the current
// pixel to the scanline in question.
// 'color' is the colour of the scanline at the horizontal location of
// the current pixel.
vec4 scanlineWeights(float distance, vec4 color)
{
    // \"wid\" controls the width of the scanline beam, for each RGB channel
    // The \"weights\" lines basically specify the formula that gives
    // you the profile of the beam, i.e. the intensity as
    // a function of distance from the vertical center of the
    // scanline. In this case, it is gaussian if width=2, and
    // becomes nongaussian for larger widths. Ideally this should
    // be normalized so that the integral across the beam is
    // independent of its width. That is, for a narrower beam
    // \"weights\" should have a higher peak at the center of the
    // scanline than for a wider beam.
    if (!scanline_gaussian)
    {
        vec4 wid = 0.3 + 0.1 * pow(abs(color), vec4(3.0));
        vec4 weights = vec4(distance / wid);
        return 0.4 * exp(-weights * weights) / wid;
    }
    else
    {
        vec4 wid = 2.0 * pow(abs(color), vec4(4.0)) + 2.0;
        vec4 weights = vec4(distance / 0.3);
        return 1.4 * exp(-pow(abs(weights * inversesqrt(0.5 * wid)), vec4(abs(wid)))) / (0.2 * wid + 0.6);
    }
}

vec3 crt_pass(sampler2D tex, vec2 texcoord)
{
    // Here's a helpful diagram to keep in mind while trying to
    // understand the code:
    //
    //  |      |      |      |      |
    // -------------------------------
    //  |      |      |      |      |
    //  |  01  |  11  |  21  |  31  | <-- current scanline
    //  |      | @    |      |      |
    // -------------------------------
    //  |      |      |      |      |
    //  |  02  |  12  |  22  |  32  | <-- next scanline
    //  |      |      |      |      |
    // -------------------------------
    //  |      |      |      |      |
    //
    // Each character-cell represents a pixel on the output
    // surface, \"@\" represents the current pixel (always somewhere
    // in the bottom half of the current scan-line, or the top-half
    // of the next scanline). The grid of lines represents the
    // edges of the texels of the underlying texture.

    float  Input_ratio = ceil(256 * resolution);
    vec2 _Resolution = vec2(Input_ratio, Input_ratio);
    vec2 rubyTextureSize = _Resolution;
    vec2 rubyInputSize = _Resolution;
    vec2 rubyOutputSize = screen_size;

    vec2 orig_xy = curvature ? transform(texcoord, rubyTextureSize, rubyInputSize) : texcoord;
    float cval = corner(orig_xy, rubyTextureSize, rubyInputSize);

    // Of all the pixels that are mapped onto the texel we are
    // currently rendering, which pixel are we currently rendering?
    vec2 ratio_scale = orig_xy * rubyTextureSize - 0.5;

    float _filter = fwidth(ratio_scale.y);
    vec2 uv_ratio = fract(ratio_scale);

    // Snap to the center of the underlying texel.
    vec2 xy = (floor(ratio_scale) + 0.5) / rubyTextureSize;

    // Calculate Lanczos scaling coefficients describing the effect
    // of various neighbour texels in a scanline on the current
    // pixel.
    vec4 coeffs = PI * vec4(1.0 + uv_ratio.x, uv_ratio.x, 1.0 - uv_ratio.x, 2.0 - uv_ratio.x);

    // Prevent division by zero.
    coeffs = FIX(coeffs);

    // Lanczos2 kernel.
    coeffs = 2.0 * sin(coeffs) * sin(coeffs / 2.0) / (coeffs * coeffs);

    // Normalize.
    coeffs /= dot(coeffs, vec4(1.0));

    // Calculate the effective colour of the current and next
    // scanlines at the horizontal location of the current pixel,
    // using the Lanczos coefficients above.
    vec4 col  = clamp(coeffs * mat4(
        TEX2D(xy + vec2(-coone.x, 0.0)),
        TEX2D(xy),
        TEX2D(xy + vec2(coone.x, 0.0)),
        TEX2D(xy + vec2(2.0 * coone.x, 0.0))),
        0.0, 1.0);
    vec4 col2 = clamp(coeffs * mat4(
        TEX2D(xy + vec2(-coone.x, coone.y)),
        TEX2D(xy + vec2(0.0, coone.y)),
        TEX2D(xy + coone),
        TEX2D(xy + vec2(2.0 * coone.x, coone.y))),
        0.0, 1.0);

#ifndef LINEAR_PROCESSING
    col  = pow(abs(col) , vec4(gamma));
    col2 = pow(abs(col2), vec4(gamma));
#endif

    // Calculate the influence of the current and next scanlines on
    // the current pixel.
    vec4 weights  = scanlineWeights(uv_ratio.y, col);
    vec4 weights2 = scanlineWeights(1.0 - uv_ratio.y, col2);

//#if __RENDERER__ < 0xa000 && !__RESHADE_PERFORMANCE_MODE__
//    [flatten]
//#endif
    if (oversample)
    {
        uv_ratio.y = uv_ratio.y + 1.0 / 3.0 * _filter;
        weights = (weights + scanlineWeights(uv_ratio.y, col)) / 3.0;
        weights2 = (weights2 + scanlineWeights(abs(1.0 - uv_ratio.y), col2)) / 3.0;
        uv_ratio.y = uv_ratio.y - 2.0 / 3.0 * _filter;
        weights = weights + scanlineWeights(abs(uv_ratio.y), col) / 3.0;
        weights2 = weights2 + scanlineWeights(abs(1.0 - uv_ratio.y), col2) / 3.0;
    }

    vec3 mul_res = (col * weights + col2 * weights2).rgb * cval;

    // dot-mask emulation:
    // Output pixels are alternately tinted green and magenta.
    vec3 dotMaskWeights = mix(vec3(1.0, 0.7, 1.0), vec3(0.7, 1.0, 0.7), floor(mod(mod_factor, scanline_intensity)));
    mul_res *= dotMaskWeights * vec3(0.83, 0.83, 1.0) * brightness;

    // Convert the image gamma for display on our output device.
    mul_res = pow(abs(mul_res), vec3(1.0 / monitor_gamma));

    vec3 color = TEX2D(orig_xy).rgb * cval;
    color = mix(color, mul_res, amount);

    return clamp(color, 0.0, 1.0);
}

"

class CRT is Node
{
	init() 
	{
		super.init(CRT.name)

		this.node_func = NodeFunction(this, CODE, "crt_pass", [
            [ "amount", 1.0, { "min" : 0.0, "max" : 1.0 } ],
            [ "resolution", 1.15, { "min" : 1.0, "max" : 8.0 } ],
            [ "gamma", 2.4, { "min" : 0.0, "max" : 4.0 } ],
            [ "monitor_gamma", 2.2, { "min" : 0.0, "max" : 4.0 } ],
            [ "brightness", 0.9, { "min" : 0.0, "max" : 3.0 } ],
            [ "scanline_intensity", 2, { "integer" : true, "min" : 2, "max" : 4 } ],
            [ "scanline_gaussian", true ],
            [ "curvature", false ],
            [ "curvature_radius", 1.5, { "min" : 0.0, "max" : 2.0 } ],
            [ "corner_size", 0.01, { "min" : 0.0, "max" : 0.02 } ],
            [ "viewer_distance", 2.0, { "min" : 0.0, "max" : 4.0 } ],
            [ "angle", Vector2(0, 0), { "min" : -0.2, "max" : 0.2 } ],
            [ "overscan", 1.01, { "min" : 1.0, "max" : 1.1 } ],
            [ "oversample", true ],
        ])
	}
}