import "blueprint.node" for Node
import "blueprint.pin" for Pin
import "blueprint.variant" for Variant, VAR_TYPE_ARRAY
import "blueprint.blueprint" for Blueprint
import "blueprint.node_param" for NodeParam
import "geograph.variant" for VAR_TYPE_GEO
import "physicsgraph.variant" for VAR_TYPE_BODY, VarBody
import "physics" for Body as tt_Body

class Body is Node
{
	init()
	{
		super.init()

		this.imports = [
			Pin(this, "geos", [ VAR_TYPE_GEO, VAR_TYPE_ARRAY ]),
		]
		this.exports = [
			Pin(this, "body", VAR_TYPE_BODY),
			Pin(this, "bodies", VAR_TYPE_ARRAY),			
		]

		this.params.add(NodeParam("type", "static", { "combo" : [ "static", "kinematic", "dynamic" ] }))

		this.layout()

		this.body = VarBody()
		this.bodies = nil
	}

	on_pin_dirty(pin)
	{
		this.body.body = nil
		this.bodies = nil
	}

	on_node_dirty()
	{
		this.body.body = nil
		this.bodies = nil
	}

	calc_value(idx)
	{
		if (idx == 0)
		{
			if (!this.body.body) 
			{
				var v_geos = Blueprint.calc_input_value(this, 0)
				this.body.body = this.build_body(v_geos)
			}
			return Variant(VAR_TYPE_BODY, this.body)
		}
		else if (idx == 1)
		{
			if (!this.bodies) 
			{
				this.bodies = []

				var v_geos = Blueprint.calc_input_value(this, 0)
				if (v_geos.type == VAR_TYPE_ARRAY)
				{
					for (var v_geo in v_geos.value)
					{
						var v_body = VarBody()
						v_body.body = this.build_body(v_geo)
						this.bodies.add(Variant(VAR_TYPE_BODY, v_body))
					}
				}
				else
				{
					var v_body = VarBody()
					v_body.body = this.build_body(v_geos)
					this.bodies.add(Variant(VAR_TYPE_BODY, v_body))
				}
			}

			return Variant(this.bodies)
		}

		return nil
	}

	build_body(v_geos)
	{
		var type = this.query_param("type").value
		var body = tt_Body.init(type)
		
		if (v_geos.type == VAR_TYPE_ARRAY)
		{
			for (var geo in v_geos.value) {
				body.add_shape(geo.value.shape, geo.value.render_style["fill"].value)
			}
		}
		else
		{
			var filled = false
			var v_fill = v_geos.value.render_style["fill"]
			if (v_fill) {
				filled = v_fill.value
			}

			body.add_shape(v_geos.value.shape, filled)
		}

		return body
	}
}