import "blueprint.node" for Node
import "blueprint.pin" for Pin
import "blueprint.variant" for Variant, VAR_TYPE_ARRAY, VAR_TYPE_INTEGER, VAR_TYPE_NUMBER2
import "blueprint.blueprint" for Blueprint
import "blueprint.node_param" for NodeParam
import "geograph.variant" for VarGeo, VAR_TYPE_GEO
import "physicsgraph.variant" for VAR_TYPE_BODY, VarBody
import "scenegraph.variant" for VAR_TYPE_SPRITE
import "physics" for Body as tt_Body
import "maths" for Matrix2D

class Body is Node
{
	init()
	{
		super.init()

		this.imports = [
			Pin(this, "geos", [ VAR_TYPE_GEO, VAR_TYPE_ARRAY ]),
			Pin(this, "flag",   VAR_TYPE_INTEGER),
			Pin(this, "pos",    VAR_TYPE_NUMBER2),
		]
		this.exports = [
			Pin(this, "body",   VAR_TYPE_BODY),
			Pin(this, "bodies", VAR_TYPE_ARRAY),
		]

		this.params.add(NodeParam("type", "static", { "combo" : [ "static", "kinematic", "dynamic" ] }))

		this.params.add(NodeParam("gravity",     1.0, { "min" : 0.0, "max" : 2.0 }))
		// todo: need fixture?
		this.params.add(NodeParam("density",     1.0, { "min" : 0.0, "max" : 2.0 }))
		this.params.add(NodeParam("restitution", 0.0, { "min" : 0.0, "max" : 2.0 }))
		this.params.add(NodeParam("friction",    0.2, { "min" : 0.0, "max" : 1.0 }))

		this.layout()

		this.body = VarBody()
	}

	calc_value(idx)
	{
		if (idx == 0)
		{
			if (!this.body.body) 
			{
				var v_geos = Blueprint.calc_input_value(this, 0)
				this.body.body   = this.build_body(v_geos)
				this.body.bodies = nil
				this.body.geos   = nil
				if (v_geos and v_geos.type == VAR_TYPE_SPRITE) {
					this.body.spr = v_geos.value
				} else {
					this.body.geo = v_geos
				}
			}
			return Variant(VAR_TYPE_BODY, this.body)
		}
		else if (idx == 1)
		{
			if (!this.body.bodies) 
			{
				var bodies = []

				var v_geos = Blueprint.calc_input_value(this, 0)
				if (v_geos.type == VAR_TYPE_ARRAY)
				{				
					for (var v_geo in v_geos.value)
					{
						var body = this.build_body(v_geo)
						if (body) {
							var v_body = VarBody()
							v_body.body = body
							bodies.add(Variant(VAR_TYPE_BODY, v_body))
						}
					}
				}
				else
				{
					var body = this.build_body(v_geos)
					if (body) {
						var v_body = VarBody()
						v_body.body = body
						bodies.add(Variant(VAR_TYPE_BODY, v_body))
					}
				}

				this.body.body = nil
				this.body.bodies = nil
				if (!bodies.isEmpty) {
					this.body.bodies = bodies
				}
				this.body.geo  = nil
				this.body.geos = v_geos
			}

			return Variant(VAR_TYPE_BODY, this.body)
		}

		return nil
	}

	build_body(v_geos)
	{
		var flag = nil
		var v_flag = Blueprint.calc_input_value(this, 1)
		if (v_flag) {
			flag = v_flag.value
		}

		var type = this.query_param("type").value
		var body = tt_Body.init(type, flag)

		var mat = Matrix2D.init()
		this.build_body(v_geos, body, mat)

		var v_body = VarBody()

		if (v_geos.type == VAR_TYPE_SPRITE and v_geos.value.transform) 
		{
			var srt = v_geos.value.transform.decompose()
			v_body.scale = [srt[0], srt[1]]
			body.set_transform([srt[3], srt[4]], srt[2])
		}

		body.set_gravity_scale(this.query_param("gravity").value)
		body.set_density(this.query_param("density").value)
		body.set_restitution(this.query_param("restitution").value)
		body.set_friction(this.query_param("friction").value)

		var v_pos = Blueprint.calc_input_value(this, 2)
		if (v_pos) {
			body.set_transform([v_pos.value.x, v_pos.value.y], 0)
		}

		return body
	}

	build_body(v_geo, body, mat)
	{
		if (v_geo.type == VAR_TYPE_ARRAY)
		{
			for (var geo in v_geo.value) {
				this.build_body(geo, body, mat)
			}
		}
		else if (v_geo.type == VAR_TYPE_GEO)
		{
			if (v_geo.value.shape) {
				var fill = v_geo.value.render_style["fill"]
				body.add_shape(v_geo.value.shape, fill, mat)
			}
		}
		else if (v_geo.type == VAR_TYPE_SPRITE)
		{
			var spr = v_geo.value
			if (spr.symbol) 
			{
				if (spr.symbol is VarGeo) 
				{
					var fill = spr.symbol.render_style["fill"]
					body.add_shape(spr.symbol.shape, fill, mat)
				} 
				else if (spr.size) 
				{
					var w = spr.size.x
					var h = spr.size.y

					var rect = Rect.init()
					rect.set(-w * 0.5, -h * 0.5, w, h)
					body.add_shape(rect, true, mat)
				}
			} 
			else 
			{
				for (var child in spr.children) {
					var c_mat = this.calc_mat(child, mat)
					this.build_body(Variant(VAR_TYPE_SPRITE, child), body, c_mat)
				}
			}
		}
	}

	calc_mat(spr, mat)
	{
		var ret = Matrix2D.init()
		if (spr.transform) {
			ret.transform_mat(spr.transform)
		}
		if (mat) {
			ret.transform_mat(mat)
		}
		return ret
	}
}