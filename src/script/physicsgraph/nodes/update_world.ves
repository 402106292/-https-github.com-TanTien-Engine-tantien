import "blueprint.node" for Node
import "blueprint.pin" for Pin
import "blueprint.variant" for VAR_TYPE_PORT
import "blueprint.blueprint" for Blueprint
import "physicsgraph.variant" for VAR_TYPE_WORLD
 import "physics" for World

class UpdateWorld is Node
{
	init()
	{
		super.init()

		this.imports = [
			Pin(this, "prev",  VAR_TYPE_PORT),
			Pin(this, "world", VAR_TYPE_WORLD),
		]
		this.exports = [
			Pin(this, "next", VAR_TYPE_PORT)
		]

		this.layout()
	}

	execute_run() 
	{
		var v_world = Blueprint.calc_input_value(this, 1)
		if (!v_world or v_world.type != VAR_TYPE_WORLD) {
			return
		}

		var w = v_world.value
		for (var b in w.bodies)
		{
			if (b.value.geo) 
			{
				this.set_geo_transform(b.value.geo.value, b.value.body)
			}
			else if (b.value.geos)
			{
				if (b.value.geos.value.count != b.value.bodies.value.count) {
					import "logger.logger" for Logger
					Logger.error("Bodies and geos number not equal.")
				}

				if (b.value.geos.value.count == b.value.bodies.value.count) 
				{
					for (var i in 0 .. b.value.geos.value.count) {
						b.value.geos.value[i].value.show = b.value.bodies.value[i].value.body.is_valid()
						this.set_geo_transform(b.value.geos.value[i].value, b.value.bodies.value[i].value.body)
					}
				}
			}
		}
	}

	set_geo_transform(geo, body)
	{
		var pos = body.get_pos()
		var s = World.get_scale_factor()
		geo.pos[0] = pos[0] * s
		geo.pos[1] = pos[1] * s

		geo.angle = body.get_angle()
	}
}