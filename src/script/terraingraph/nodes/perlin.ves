import "blueprint.node" for Node
import "terraingraph.node_helper" for NodeHelper
import "terraingraph.style" for HEIGHTFIELD_SIZE
import "terraingraph.heightfield_proxy" for HeightfieldProxy
import "terraingraph.variant" for VAR_TYPE_HEIGHTFIELD, VarHeightfield
import "blueprint.pin" for Pin
import "blueprint.variant" for Variant
import "blueprint.field_proxy" for FieldProxy
import "blueprint.node_layout" for DEFAULT_HEIGHT
import "image" for ImageData
import "render" for Texture2D
import "gui" for GUI
import "blueprint.blueprint" for Blueprint
import "rendergraph.nodes.shader" for Shader
import "rendergraph.nodes.compute" for Compute
import "rendergraph.nodes.texture" for Texture
import "rendergraph.drawlist" for Drawlist

var DARWLIST = nil
var SHADER   = nil
var COMPUTE  = nil

var CS = "
#version 430

#define LOCAL_SIZE 32

layout(local_size_x = LOCAL_SIZE, local_size_y = LOCAL_SIZE, local_size_z = 1) in;

layout(binding = 0, r16f) writeonly uniform image2D out_tex;

uniform sampler2D perlin_perm2d_tex;
uniform sampler2D perlin_grad2d_tex;

uniform UBO
{
	float frequency;
	float seed;	
};

float perlin_noise(vec2 p, float seed)
{
	// Calculate 2D integer coordinates i and fraction p.
	vec2 i = floor(p);
	vec2 f = p - i;

	// Get weights from the coordinate fraction
	vec2 w = f * f * f * (f * (f * 6 - 15) + 10);
	vec4 w4 = vec4(1, w.x, w.y, w.x * w.y);

	// Get the four randomly permutated indices from the noise lattice nearest to
	// p and offset these numbers with the seed number.
	vec4 perm = texture(perlin_perm2d_tex, i / 256) + seed;

	// Permutate the four offseted indices again and get the 2D gradient for each
	// of the four permutated coordinates-seed pairs.
	vec4 g1 = texture(perlin_grad2d_tex, perm.xy) * 2 - 1;
	vec4 g2 = texture(perlin_grad2d_tex, perm.zw) * 2 - 1;

	// Evaluate the four lattice gradients at p
	float a = dot(g1.xy, f);
	float b = dot(g2.xy, f + vec2(-1,  0));
	float c = dot(g1.zw, f + vec2( 0, -1));
	float d = dot(g2.zw, f + vec2(-1, -1));

	// Bi-linearly blend between the gradients, using w4 as blend factors.
	vec4 grads = vec4(a, b - a, c - a, a - b - c + d);
	float n = dot(grads, w4);

	// Return the noise value, roughly normalized in the range [-1, 1]
	return n * 1.5;
}

void main()
{
	ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    const vec2 tex_coord = pos / float(imageSize(out_tex));

    vec2 st = (tex_coord/* + u_offset*/) * frequency;

	float height = perlin_noise(st, seed);
	float v = height * 0.5f + 0.5f;

    v = clamp(v, 0.0, 1.0);
    
    imageStore(out_tex, pos, vec4(v));
}
"

class Perlin is Node
{
	init() 
	{
		super.init(Perlin.name)
	
		this.exports = [
			Pin(this, "out", VAR_TYPE_HEIGHTFIELD)
		]

		this.layout()

		this.frequency = 4
		this.seed = 0

		this.hf = VarHeightfield()
	}

	calc(idx)
	{
		return Variant(VAR_TYPE_HEIGHTFIELD, this.hf)
	}

	execute()
	{
		if (!this.hf.tex) {
			this.hf.tex = Texture2D.init(HEIGHTFIELD_SIZE, HEIGHTFIELD_SIZE, "r16f")
		}
		if (!DARWLIST) 
		{
			var shader = Shader()
			shader.cs = CS
			shader.execute()

			var perm2d_tex = Texture()
			perm2d_tex.init_texture("assets/textures/noise/perlin_perm2d.png")
			Blueprint.connect(perm2d_tex, "tex", shader, "perlin_perm2d_tex")

			var grad2d_tex = Texture()
			grad2d_tex.init_texture("assets/textures/noise/perlin_grad2d.png")
			Blueprint.connect(grad2d_tex, "tex", shader, "perlin_grad2d_tex")

			var compute = Compute()
			compute.num_groups = [ HEIGHTFIELD_SIZE / 32, HEIGHTFIELD_SIZE / 32, 1 ]

			Blueprint.connect(shader, "out", compute, "shader")

			DARWLIST = Drawlist([compute])

			SHADER = shader
			COMPUTE = compute
		}

		if (this.dirty) 
		{
			COMPUTE.dirty = true
			this.bind(SHADER)
			DARWLIST.draw()

			this.dirty = false
		}
	}

	layout() 
	{
		super.layout()

		this.style.height = this.style.height + DEFAULT_HEIGHT * 2
	}

	to_string(name) {
		return "
%(name).frequency = %(this.frequency)
%(name).seed = %(this.seed)
"
	}
	
	draw_gui(ctx) 
	{
		var dirty = false

		var x = this.pos.x - this.style.width * 0.5
		var y = this.pos.y + this.style.height * 0.5 - this.calc_panel_height() - DEFAULT_HEIGHT

		var REGION = 10
		var freq = GUI.slider(ctx, "freq", this.frequency, x, y, this.style.width - 20, REGION, false)
		if (freq != this.frequency) {
			this.frequency = freq
			dirty = true
		}
		y = y - DEFAULT_HEIGHT

		var seed = GUI.slider(ctx, "seed", this.seed, x, y, this.style.width - 20, 1.0, false)
		if (seed != this.seed) {
			this.seed = seed
			dirty = true
		}
		y = y - DEFAULT_HEIGHT

		if (dirty) {
			NodeHelper.make_node_dirty(this)
		}

		return dirty
	}

	bind(shader)
	{
		var pout = HeightfieldProxy(this.exports[0])
		Blueprint.connect(pout, "tex", shader, "out_tex")

		var pfreq = FieldProxy(this, "frequency")
		Blueprint.connect(pfreq, "out", shader, "frequency")

		var pseed = FieldProxy(this, "seed")
		Blueprint.connect(pseed, "out", shader, "seed")
	}
}