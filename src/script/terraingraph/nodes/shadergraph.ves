import "blueprint.nodes.subgraph" for Subgraph
import "blueprint.pin" for Pin
import "blueprint.variant" for Variant
import "blueprint.blueprint" for Blueprint
import "blueprint.shader_gen" for ShaderContext
import "terraingraph.style" for HEIGHTFIELD_SIZE
import "terraingraph.heightfield_proxy" for HeightfieldProxy
import "terraingraph.variant" for VAR_TYPE_HEIGHTFIELD, VarHeightfield
import "rendergraph.nodes.shader" for Shader
import "rendergraph.nodes.compute" for Compute
import "rendergraph.nodes.texture" for Texture
import "rendergraph.drawlist" for Drawlist
import "render" for Texture2D
import "shader" for ShaderGen

var DARWLIST = nil
var SHADER   = nil
var COMPUTE  = nil

var CS = ""

class ShaderBuilder
{
	init()
	{
		this.uniform_nodes = []
		this.uniform_funcs = []
	}

	build(node)
	{
		this.uniform_nodes = []
		this.uniform_funcs = []

		var gen = ShaderGen.init()
		var module = gen.get_main_module()
		var func = gen.get_main_func()
		var bb = func.get_block()
		var ctx = ShaderContext(gen, module, func, bb, {})

		var prev_nodes = Blueprint.get_precursor_nodes(node)
		var list = Blueprint.topo_sort(prev_nodes)
		for (var node in list) {
			if (node is Subgraph) {
				node.shader_build(this, gen)
			} else {
				this.build(node, ctx)
			}
		}

		return gen
	}

	build(node, ctx)
	{
		if (node["node_func"]) {
			node.node_func.shader_gen(ctx)
			if (node.node_func.has_uniforms()) {
				this.uniform_funcs.add(node.node_func)
			}
		} 
		if (node.has_method("shader_gen(_)")) {
			node.shader_gen(ctx)
		}
		if (node.has_method("bind_uniforms(_)")) {
			this.uniform_nodes.add(node)
		}
	}

	bind_uniforms(prog)
	{
		for (var node in this.uniform_nodes) {
			node.bind_uniforms(prog)
		}
		for (var func in this.uniform_funcs) {
			func.bind_uniforms(prog)
		}
	}
}

class Shadergraph is Subgraph
{
	init() 
	{
		super.init(Shadergraph.name)

		this.imports.clear()
		this.exports.clear()

		this.exports = [
			Pin(this, "out", VAR_TYPE_HEIGHTFIELD)
		]

		this.layout()

		this.hf = VarHeightfield()
	}

	calc_value(idx)
	{
		return Variant(VAR_TYPE_HEIGHTFIELD, this.hf)
	}

	execute()
	{
		if (!this.hf.tex) {
			this.hf.tex = Texture2D.init(HEIGHTFIELD_SIZE, HEIGHTFIELD_SIZE, "r16f")
		}
		if (this.dirty) {
			this.rebuild_shader()
		}
		if (!DARWLIST) 
		{
			var shader = Shader()
			shader.cs = CS
			shader.execute()

			var perm2d_tex = Texture()
			perm2d_tex.init_texture("assets/textures/noise/perlin_perm2d.png")
			perm2d_tex.set_sampler("linear_repeat")
			Blueprint.connect(perm2d_tex, "tex", shader, "perlin_perm2d_tex")

			var grad2d_tex = Texture()
			grad2d_tex.init_texture("assets/textures/noise/perlin_grad2d.png")
			grad2d_tex.set_sampler("linear_repeat")
			Blueprint.connect(grad2d_tex, "tex", shader, "perlin_grad2d_tex")

			var compute = Compute()
			compute.num_groups = [ HEIGHTFIELD_SIZE / 32, HEIGHTFIELD_SIZE / 32, 1 ]

			Blueprint.connect(shader, "out", compute, "shader")

			DARWLIST = Drawlist([compute])

			SHADER = shader
			COMPUTE = compute
		}

		if (this.dirty) 
		{
			COMPUTE.dirty = true
			this.bind(SHADER)

			if (this.builder) {
				this.builder.bind_uniforms(SHADER.shader.prog)
			}

			DARWLIST.draw()

			this.dirty = false
		}
	}

	find_output_node()
	{
		import "blueprint.nodes.output"	for Output

		for (var item in this.all_items) {
			var node = item[0]
			if (node is Output) {
				return node
			}
		}

		return nil
	}

	rebuild_shader()
	{
		var node = this.find_output_node()
		if (!node) {
			return
		}

		this.builder = ShaderBuilder()
		var gen = this.builder.build(node)

		var module = gen.get_main_module()
		var func = gen.get_main_func()
		var bb = func.get_block()

		var dst = func.variable_float()
		var ctx = ShaderContext(gen, module, func, bb, {})
		var grey = Blueprint.calc_input_inst(node, 0, ctx)
		bb.store(dst, grey)

		bb.return_null()

		CS = gen.connect_cs_main("
#define LOCAL_SIZE 32

layout(local_size_x = LOCAL_SIZE, local_size_y = LOCAL_SIZE, local_size_z = 1) in;

layout(binding = 0, r16f) writeonly uniform image2D out_tex;

void main()
{
	ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    vec2 tex_coords = pos / float(imageSize(out_tex));
    //float v = perlin_noise(tex_coords * 10, 0.0);
    float v = turbulence(tex_coords, 0, 5, 3, 0.5);
    imageStore(out_tex, pos, vec4(v));
}
")

		System.print(CS)
	}

	bind(shader)
	{
		var pout = HeightfieldProxy(this.exports[0])
		Blueprint.connect(pout, "tex", shader, "out_tex")
	}

	setup_popup_nodes(editor)
	{
		editor.clear_popup_nodes()

		import "editor.noisenodes" for NOISE_NODES
		for (var node in NOISE_NODES) {
			editor.add_popup_node(node)
		}

		import "blueprint.nodes.output"	for Output
		editor.add_popup_node(Output)
	}

	import_files_header()
	{
		return "
import \"blueprint.blueprint\" for Blueprint
import \"blueprint.nodes.*\"
import \"shadergraph.nodes.*\"
import \"noisegraph.nodes.*\"
"
	}
}