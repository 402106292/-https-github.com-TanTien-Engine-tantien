import "blueprint.node" for Node
import "terraingraph.node_helper" for NodeHelper
import "terraingraph.style" for HEIGHTFIELD_SIZE
import "terraingraph.heightfield_proxy" for HeightfieldProxy
import "terraingraph.variant" for VAR_TYPE_HEIGHTFIELD, VarHeightfield
import "blueprint.pin" for Pin
import "blueprint.variant" for Variant
import "blueprint.field_proxy" for FieldProxy
import "image" for ImageData
import "render" for Texture2D, Render
import "blueprint.node_layout" for DEFAULT_HEIGHT
import "gui" for GUI
import "blueprint.blueprint" for Blueprint
import "rendergraph.nodes.shader" for Shader
import "rendergraph.nodes.compute" for Compute
import "rendergraph.drawlist" for Drawlist

var DARWLIST = nil
var SHADER   = nil
var COMPUTE  = nil

var CS = "
#version 430

#define LOCAL_SIZE 32

layout(local_size_x = LOCAL_SIZE, local_size_y = LOCAL_SIZE, local_size_z = 1) in;

layout(binding = 0, r16f) writeonly uniform image2D out_tex;

uniform sampler2D in_tex;

uniform UBO
{
	float dx;
	float dy;
	float rot;
	float scale;	
};

void main()
{
	ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = pos / float(imageSize(out_tex));

    // scale
    uv = (uv - vec2(0.5, 0.5)) * scale + vec2(0.5, 0.5);
    // rotate
    float sin_factor = sin(rot);
    float cos_factor = cos(rot);
    uv = vec2(uv.x - 0.5, uv.y - 0.5) * mat2(cos_factor, sin_factor, -sin_factor, cos_factor) + vec2(0.5, 0.5);
    // translate
    uv = uv + vec2(dx, dy);

    float h = texture(in_tex, uv).r;
    imageStore(out_tex, pos, vec4(h));
}
"	

class Transform is Node
{
	init() 
	{
		super.init(Transform.name)

		this.imports = [
			Pin(this, "in", VAR_TYPE_HEIGHTFIELD)
		]	
		this.exports = [
			Pin(this, "out", VAR_TYPE_HEIGHTFIELD)
		]

		this.layout()

		this.dx = 0
		this.dy = 0
		this.rot = 0
		this.scale = 1.0

		this.hf = VarHeightfield()
	}

	calc(idx)
	{
		return Variant(VAR_TYPE_HEIGHTFIELD, this.hf)
	}

	execute()
	{
		if (!this.hf.tex) {
			this.hf.tex = Texture2D.init(HEIGHTFIELD_SIZE, HEIGHTFIELD_SIZE, "r16f")
		}
		if (!DARWLIST) 
		{
			var shader = Shader()
			shader.cs = CS
			shader.execute()

			var compute = Compute()
			compute.num_groups = [ HEIGHTFIELD_SIZE / 32, HEIGHTFIELD_SIZE / 32, 1 ]

			Blueprint.connect(shader, "out", compute, "shader")

			DARWLIST = Drawlist([compute])

			SHADER = shader
			COMPUTE = compute
		}

		if (this.dirty) 
		{
			COMPUTE.dirty = true
			this.bind(SHADER)
			DARWLIST.draw()

			this.dirty = false
		}
	}

	layout() 
	{
		super.layout()

		this.style.height = this.style.height + DEFAULT_HEIGHT * 4
	}

	to_string(name) {
		return "
%(name).dx = %(this.dx)
%(name).dy = %(this.dy)
%(name).rot = %(this.rot)
%(name).scale = %(this.scale)
"
	}

	draw_gui(ctx) 
	{
		var dirty = false

		var x = this.pos.x - this.style.width * 0.5
		var y = this.pos.y + this.style.height * 0.5 - this.calc_panel_height() - DEFAULT_HEIGHT

		var REGION = 1

		var dx = GUI.slider(ctx, "dx", this.dx, x, y, this.style.width - 20, REGION, false)
		if (dx != this.dx) {
			this.dx = dx
			dirty = true
		}

		y = y - DEFAULT_HEIGHT
		var dy = GUI.slider(ctx, "dy", this.dy, x, y, this.style.width - 20, REGION, false)
		if (dy != this.dy) {
			this.dy = dy
			dirty = true
		}

		y = y - DEFAULT_HEIGHT
		var rot = GUI.slider(ctx, "rot", this.rot, x, y, this.style.width - 20, 6.28, false)
		if (rot != this.rot) {
			this.rot = rot
			dirty = true
		}

		y = y - DEFAULT_HEIGHT
		var scale = GUI.slider(ctx, "scale", this.scale, x, y, this.style.width - 20, 2.0, false)
		if (scale != this.scale) {
			this.scale = scale
			dirty = true
		}

		if (dirty) {
			NodeHelper.make_node_dirty(this)
		}

		return dirty
	}

	bind(shader)
	{
		var out_tex = HeightfieldProxy(this.exports[0])
		Blueprint.connect(out_tex, "tex", shader, "out_tex")

		var in_tex = HeightfieldProxy(this.imports[0])
		Blueprint.connect(in_tex, "tex", shader, "in_tex")

		var dx = FieldProxy(this, "dx")
		Blueprint.connect(dx, "out", shader, "dx")

		var dy = FieldProxy(this, "dy")
		Blueprint.connect(dy, "out", shader, "dy")

		var rot = FieldProxy(this, "rot")
		Blueprint.connect(rot, "out", shader, "rot")

		var scale = FieldProxy(this, "scale")
		Blueprint.connect(scale, "out", shader, "scale")
	}
}