import "shadergraph.node_helper" for NodeHelper
import "blueprint.node" for Node
import "blueprint.node_layout" for DEFAULT_HEIGHT
import "gui" for GUI

var block = "

// proposed solution from
// http://stackoverflow.com/questions/26070410/robust-atany-x-on-glsl-for-converting-xy-coordinate-to-angle
// swaps params when |x| <= |y|
float atan2(float y, float x)
{
    bool s = (abs(x) > abs(y));
    return mix(3.14159265358979/2.0 - atan(x,y), atan(y,x), s);
}

// https://stackoverflow.com/questions/7610631/glsl-mod-vs-hlsl-fmod
float fmod(float x, float y)
{
    //return x â€“ y * trunc(x/y);
    return x - y * floor(x/y);
}

// https://docs.unity3d.com/Packages/com.unity.shadergraph@9.0/manual/Rounded-Polygon-Node.html
float rounded_polygon(vec2 uv, float width, float height, float sides, float roundness)
{
    const float PI = 3.14159265359;
    const float HALF_PI = 1.570796327;

    vec2 st = uv * 2. + vec2(-1.,-1.);
    // fixme: parser
    //float epsilon = 1e-6;
    //st.x = st.x / ( width + (width==0?1:0)*epsilon);
    //st.y = st.y / ( height + (height==0?1:0)*epsilon);
    //roundness = clamp(roundness, 1e-6, 1.);
    float epsilon = 0;
    st.x = st.x / ( width + ((width==0)?1:0)*epsilon);
    st.y = st.y / ( height + ((height==0)?1:0)*epsilon);
    float _roundness = clamp(roundness, 0., 1.);
    float i_sides = floor( abs( sides ) );
    float fullAngle = 2. * PI / i_sides;
    float halfAngle = fullAngle / 2.;
    float opositeAngle = HALF_PI - halfAngle;
    float diagonal = 1. / cos( halfAngle );
    // Chamfer values
    float chamferAngle = _roundness * halfAngle; // Angle taken by the chamfer
    float remainingAngle = halfAngle - chamferAngle; // Angle that remains
    float ratio = tan(remainingAngle) / tan(halfAngle); // This is the ratio between the length of the polygon's triangle and the distance of the chamfer center to the polygon center
    // Center of the chamfer arc
    vec2 chamferCenter = vec2(
        cos(halfAngle) ,
        sin(halfAngle)
    )* ratio * diagonal;
    // starting of the chamfer arc
    vec2 chamferOrigin = vec2(
        1.,
        tan(remainingAngle)
    );
    // Using Al Kashi algebra, we determine:
    // The distance distance of the center of the chamfer to the center of the polygon (side A)
    float distA = length(chamferCenter);
    // The radius of the chamfer (side B)
    float distB = 1. - chamferCenter.x;
    // The refence length of side C, which is the distance to the chamfer start
    float distCref = length(chamferOrigin);
    // This will rescale the chamfered polygon to fit the st space
    // diagonal = length(chamferCenter) + distB;
    float uvScale = diagonal;
    st *= uvScale;
    vec2 polaruv = vec2 (
        atan2( st.y, st.x ),
        length(st)
    );
    polaruv.x += HALF_PI + 2*PI;
    polaruv.x = fmod( polaruv.x + halfAngle, fullAngle );
    polaruv.x = abs(polaruv.x - halfAngle);
    st = vec2( cos(polaruv.x), sin(polaruv.x) ) * polaruv.y;
    // Calculate the angle needed for the Al Kashi algebra
    float angleRatio = 1. - (polaruv.x-remainingAngle) / chamferAngle;
    // Calculate the distance of the polygon center to the chamfer extremity
    float distC = sqrt( distA*distA + distB*distB - 2.*distA*distB*cos( PI - halfAngle * angleRatio ) );
    float ret = st.x;
    // fixme: parser
    //float chamferZone = ( halfAngle - polaruv.x ) < chamferAngle ? 1 : 0;
    float chamferZone = (( halfAngle - polaruv.x ) < chamferAngle) ? 1 : 0;
    ret = mix( st.x, polaruv.y / distC, chamferZone );
    // Output this to have the shape mask instead of the distance field
    ret = clamp((1 - ret) / fwidth(ret), 0.0, 1.0);
    return ret;
}

"

class RoundedPolygon is Node
{
	init() 
	{
		super.init(RoundedPolygon.name)

		NodeHelper.init_pins_from_code(this, block, "rounded_polygon")

		this.sides = 5
		this.width = 0.5
		this.height = 0.5
		this.roundness = 0.1
	}

	layout() 
	{
		super.layout()

		this.style.height = this.style.height + DEFAULT_HEIGHT * 4
	}

	to_string(name) {
		return "
%(name).sides = %(this.sides)
%(name).width = %(this.width)
%(name).height = %(this.height)
%(name).roundness = %(this.roundness)
"
	}

	draw_gui(ctx) 
	{
		var dirty = false

		var x = this.pos.x - this.style.width * 0.5
		var y = this.pos.y + this.style.height * 0.5 - this.calc_panel_height() - DEFAULT_HEIGHT

		var sides = GUI.slider(ctx, "sides", this.sides, x, y, this.style.width - 20, 20, false)
		if (sides != this.sides) {
			this.sides = sides
			dirty = true
		}
		y = y - DEFAULT_HEIGHT

		var width = GUI.slider(ctx, "width", this.width, x, y, this.style.width - 20, 1, false)
		if (width != this.width) {
			this.width = width
			dirty = true
		}
		y = y - DEFAULT_HEIGHT

		var height = GUI.slider(ctx, "height", this.height, x, y, this.style.width - 20, 1, false)
		if (height != this.height) {
			this.height = height
			dirty = true
		}
		y = y - DEFAULT_HEIGHT

		var roundness = GUI.slider(ctx, "roundness", this.roundness, x, y, this.style.width - 20, 1, false)
		if (roundness != this.roundness) {
			this.roundness = roundness
			dirty = true
		}
		y = y - DEFAULT_HEIGHT

		return dirty
	}

	gen_shader(gen)
	{
		var code = "#version 330 core\n" + block	
		var lib = gen.add_lib("pixel", code)
		this.func = gen.get_func(lib, 2)
		gen.add_link_decl(this.func, "sg_RoundedPolygon", true)
	}

	calc_inst(gen, idx) 
	{
		var func = gen.create_decl_func(this.func)
		gen.add_link_decl(func, "sg_RoundedPolygon", false)

		var uv = NodeHelper.calc_input_inst(gen, this, "uv")
		if (!uv) {
			uv = gen.op_const_float2(0, 0)
		}
		var sides = NodeHelper.calc_input_inst(gen, this, "sides")
		if (!sides) {
			sides = gen.op_const_float(this.sides)
		}
		var width = NodeHelper.calc_input_inst(gen, this, "width")
		if (!width) {
			width = gen.op_const_float(this.width)
		}
		var height = NodeHelper.calc_input_inst(gen, this, "height")
		if (!height) {
			height = gen.op_const_float(this.height)
		}
		var roundness = NodeHelper.calc_input_inst(gen, this, "roundness")
		if (!roundness) {
			roundness = gen.op_const_float(this.roundness)
		}

		return gen.op_call(func, [uv, width, height, sides, roundness])
	}
}