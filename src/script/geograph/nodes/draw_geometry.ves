import "blueprint.node" for Node
import "blueprint.pin" for Pin
import "blueprint.blueprint" for Blueprint
import "blueprint.variant" for VAR_TYPE_ARRAY, VAR_TYPE_PORT, VAR_TYPE_RECT, VAR_TYPE_NUMBER2, VAR_TYPE_NUMBER3
import "blueprint.node_param" for NodeParam
import "geograph.variant" for VAR_TYPE_GEO, VarGeo
import "geograph.config" for POINT_RADIUS
import "graphics" for Painter, Graphics
import "geometry" for Line, Rect, Circle, Polyline, Polygon
import "maths.vector" for Vector2, Vector3
import "maths.rect" for Rect as tt_Rect

class DrawGeometry is Node
{
	init()
	{
		super.init()

		this.imports = [
			Pin(this, "prev",   VAR_TYPE_PORT),
			Pin(this, "geos", [ VAR_TYPE_NUMBER2, VAR_TYPE_RECT, VAR_TYPE_GEO, VAR_TYPE_ARRAY ]),
			Pin(this, "color",  VAR_TYPE_NUMBER3),
		]
		this.exports = [
			Pin(this, "next", VAR_TYPE_PORT)
		]

		this.params.add(NodeParam("skip", false))

		this.layout()
	}

	render_run() 
	{
		if (this.query_param("skip").value) {
			return
		}

		var v_geos = Blueprint.calc_input_value(this, 1)
		if (!v_geos or !v_geos.value) {
			return
		}

		var color = nil
		var v_color = Blueprint.calc_input_value(this, 2)
		if (v_color) {
			color = v_color.value
		}

		var pt = Painter.init()
		this.draw_geo(pt, v_geos, color)

		import "blueprint.blackboard" for BLACKBOARD
		var cam = BLACKBOARD.editor_cam
		Graphics.on_cam_update(cam.pos.x, cam.pos.y, cam.scale)
		Graphics.draw_painter(pt)
	}

	draw_geo(pt, v_geo, color)
	{
		if (v_geo is Vector2)
		{
			this.draw_prim_val(pt, v_geo, color)
		}
		else if (v_geo.type == VAR_TYPE_ARRAY)
		{
			for (var v in v_geo.value) {
				this.draw_geo(pt, v, color)
			}
		}
		else
		{
			var geo = v_geo.value
			if (geo is VarGeo) {
				this.draw_geo_shape(pt, geo, color)
			} else {
				this.draw_prim_val(pt, geo, color)
			}
		}
	}

	draw_prim_val(pt, geo, color)
	{
		if (!color) {
			color = Vector3(1.0, 0.0, 0.0)
		}
		var col_array = [255 * color.x, 255 * color.y, 255 * color.z, 255]

		if (geo is Vector2)
		{
			pt.add_circle_filled(geo.x, geo.y, POINT_RADIUS, col_array, 24)
		}
		else if (geo is tt_Rect)
		{
			pt.add_rect([ geo.x, geo.y, geo.w, geo.h ], col_array, 2)
		}
	}

	draw_geo_shape(pt, geo, color)
	{
		if (!color) {
			color = geo.render_style["color"]
		}
		if (!color) {
			color = Vector3(1.0, 0.0, 0.0)
		}
		var col_array = [255 * color.x, 255 * color.y, 255 * color.z, 255]

		var shape = geo.shape
		if (shape is Line) {
			this.draw_line(pt, geo, col_array)
		} else if (shape is Rect) {
			this.draw_rect(pt, geo, col_array)
		} else if (shape is Circle) {
			this.draw_circle(pt, geo, col_array)
		} else if (shape is Polyline) {
			this.draw_polyline(pt, geo, col_array)
		} else if (shape is Polygon) {
			this.draw_polygon(pt, geo, col_array)
		}
	}

	draw_line(pt, geo, col)
	{
		var line = geo.shape.get()
		if (geo.pos) {
			line[0] = line[0] + geo.pos[0]
			line[1] = line[1] + geo.pos[1]
			line[2] = line[2] + geo.pos[0]
			line[3] = line[3] + geo.pos[1]
		}

		pt.add_line(line, col, 2)
	}

	draw_rect(pt, geo, col)
	{
		var rect = geo.shape.get()
		var fill = geo.render_style["fill"]
		if (geo.angle == 0)
		{
			if (geo.pos) {
				rect[0] = rect[0] + geo.pos[0]
				rect[1] = rect[1] + geo.pos[1]
			}
			if (fill) {
				pt.add_rect_filled(rect, col)
			} else {
				pt.add_rect(rect, col, 2)	
			}
		}
		else
		{
			var quad = [
				Vector2(rect[0], rect[1]),
				Vector2(rect[0], rect[1] + rect[3]),
				Vector2(rect[0] + rect[2], rect[1] + rect[3]),
				Vector2(rect[0] + rect[2], rect[1]),
			]
			// rotate
			for (var v in quad) {
				v.rotate(geo.angle)
			}
			// translate
			if (geo.pos) 
			{
				for (var v in quad) {
					v.x = v.x + geo.pos[0]
					v.y = v.y + geo.pos[1]
				}
			}

			var vertices = []
			for (var v in quad) {
				vertices.add(v.x)
				vertices.add(v.y)
			}
			if (fill) {
				pt.add_polygon_filled(vertices, col)
			} else {
				pt.add_polygon(vertices, col, 2)
			}
		}
	}

	draw_circle(pt, geo, col)
	{
		var circle = geo.shape.get()

		var center = Vector2(circle[0], circle[1])
		center.rotate(geo.angle)
		if (geo.pos) {
			center.x = center.x + geo.pos[0]
			center.y = center.y + geo.pos[1]
		}

		var radius = circle[2]

		var fill = geo.render_style["fill"]
		if (fill) {
			pt.add_circle_filled(center.x, center.y, radius, col, 24)
		} else {
			pt.add_circle(center.x, center.y, radius, col, 2.0, 24)
		}
	}

	draw_polyline(pt, geo, col)
	{
		var verts = geo.shape.get_vertices()
		if (geo.pos) {
			for (var i = 0; i < verts.count; i = i + 2) {
				verts[i] = verts[i] + geo.pos[0]
				verts[i + 1] = verts[i + 1] + geo.pos[1]
			}
		}

		pt.add_polyline(verts, col, 2.0)
	}

	draw_polygon(pt, geo, col)
	{
		var verts = geo.shape.get_vertices()

		// rotate
		if (geo.angle != 0)
		{
			for (var i = 0; i < verts.count; i = i + 2) {
				var p = Vector2(verts[i], verts[i + 1])
				p.rotate(geo.angle)
				verts[i] = p.x
				verts[i + 1] = p.y
			}
		}

		// translate
		if (geo.pos) 
		{
			for (var i = 0; i < verts.count; i = i + 2) {
				verts[i] = verts[i] + geo.pos[0]
				verts[i + 1] = verts[i + 1] + geo.pos[1]
			}
		}

		pt.add_polygon_filled(verts, col)
	}
}