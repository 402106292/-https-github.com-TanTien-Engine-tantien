import "blueprint.node" for Node
import "blueprint.pin" for Pin
import "blueprint.node_param" for NodeParam
import "blueprint.blueprint" for Blueprint
import "blueprint.variant" for Variant, VAR_TYPE_ARRAY, VAR_TYPE_NUMBER, VAR_TYPE_NUMBER3
import "geograph.variant" for VAR_TYPE_GEO, VAR_TYPE_POLY_FACE, VarPolyFace
import "maths.cube" for Cube
import "maths.vector" for Vector3
import "maths" for Maths
import "math" for Math

class SelPolyFaces is Node
{
	init()
	{
		super.init()

		this.imports = [
			Pin(this, "brush",  VAR_TYPE_GEO),
			Pin(this, "normal", VAR_TYPE_NUMBER3),
			Pin(this, "region", VAR_TYPE_NUMBER),			
		]
		this.exports = [
			Pin(this, "faces", VAR_TYPE_ARRAY),
		]

		this.params.add(NodeParam("normal", Vector3(0, 1, 0), { "min" : -1, "max" : 1 }))
		this.params.add(NodeParam("region", 0.1, { "region" : 3.14 }))

		this.layout()
	}

	on_pin_dirty(pin)
	{
		if (pin.is_input) {
			Blueprint.send_pin_dirty(this.exports[0])
		}	
	}
	
	calc_value(idx)
	{
		var v_brush = Blueprint.calc_input_value(this, 0)
		if (!v_brush) {
			return nil
		}

		var v_normal = this.calc_in_normal()
		var v_region = this.calc_in_region()

		var ret = []

		for (var poly in v_brush.value.shape.polys)
		{
			var faces = poly.get_faces()
			for (var f in faces) 
			{
				var norm = f.get_normal()
				var angle = Maths.calc_angle([0, 0, 0], norm, [ v_normal.x, v_normal.y, v_normal.z ])
				if (Math.abs(angle) < v_region) 
				{
					var pf = VarPolyFace()
					pf.poly = poly
					pf.face = f
					ret.add(Variant(VAR_TYPE_POLY_FACE, pf))
				}
			}
		}

		return Variant(ret)
	}

	calc_in_normal()
	{
		var normal = nil
		var v_normal = Blueprint.calc_input_value(this, 1)
		if (v_normal) {
			normal = v_normal.value
		} else {
			normal = this.query_param("normal").value
		}
		return normal
	}

	calc_in_region()
	{
		var region = nil
		var v_region = Blueprint.calc_input_value(this, 2)
		if (v_region) {
			region = v_region.value
		} else {
			region = this.query_param("region").value
		}
		return region
	}	
}