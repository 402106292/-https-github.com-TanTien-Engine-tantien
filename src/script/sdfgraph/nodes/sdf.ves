import "blueprint.node" for Node
import "blueprint.pin" for Pin
import "shadergraph.node_function" for NodeFunction
import "shadergraph.variant" for VAR_TYPE_FUNCTION
import "shadergraph.node_helper" for NodeHelper
import "shadergraph.nodes.parameter" for Parameter
import "render" for Render
import "blueprint.blueprint" for Blueprint

var CODE = "
const int MAX_MARCHING_STEPS = 255;
const float MIN_DIST = 0.0;
const float MAX_DIST = 100.0;
const float EPSILON = 0.0001;

float f_scene(vec3 p)
{
    return 0;
}

float shortest_distance_to_surface(vec3 eye, vec3 marchingDirection, float start, float end)
{
    float depth = start;
    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {
        float dist = f_scene(eye + depth * marchingDirection);
        if (dist < EPSILON) {
			return depth;
        }
        depth += dist;
        if (depth >= end) {
            return end;
        }
    }
    return end;
}

vec3 ray_dir(float fov, vec2 size, vec2 frag_coord)
{
    vec2 xy = frag_coord - size / 2.0;
    float z = size.y / tan(radians(fov) / 2.0);
    return normalize(vec3(xy, -z));
}

mat3 viewMatrix(vec3 eye, vec3 center, vec3 up)
{
    // Based on gluLookAt man page
    vec3 f = normalize(center - eye);
    vec3 s = normalize(cross(f, up));
    vec3 u = cross(s, f);
    return mat3(s, u, -f);
}

vec3 estimateNormal(vec3 p) {
    return normalize(vec3(
        f_scene(vec3(p.x + EPSILON, p.y, p.z)) - f_scene(vec3(p.x - EPSILON, p.y, p.z)),
        f_scene(vec3(p.x, p.y + EPSILON, p.z)) - f_scene(vec3(p.x, p.y - EPSILON, p.z)),
        f_scene(vec3(p.x, p.y, p.z  + EPSILON)) - f_scene(vec3(p.x, p.y, p.z - EPSILON))
    ));
}

vec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,
                          vec3 lightPos, vec3 lightIntensity) {
    vec3 N = estimateNormal(p);
    vec3 L = normalize(lightPos - p);
    vec3 V = normalize(eye - p);
    vec3 R = normalize(reflect(-L, N));

    float dotLN = dot(L, N);
    float dotRV = dot(R, V);

    if (dotLN < 0.0) {
        // Light not visible from this point on the surface
        return vec3(0.0, 0.0, 0.0);
    }

    if (dotRV < 0.0) {
        // Light reflection in opposite direction as viewer, apply only diffuse
        // component
        return lightIntensity * (k_d * dotLN);
    }
    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));
}

vec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {
    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);
    vec3 color = ambientLight * k_a;

    float iTime = 0;

    vec3 light1Pos = vec3(4.0 * sin(iTime),
                          2.0,
                          4.0 * cos(iTime));
    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);

    color += phongContribForLight(k_d, k_s, alpha, p, eye,
                                  light1Pos,
                                  light1Intensity);

    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),
                          2.0 * cos(0.37 * iTime),
                          2.0);
    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);

    color += phongContribForLight(k_d, k_s, alpha, p, eye,
                                  light2Pos,
                                  light2Intensity);
    return color;
}

vec3 sdf(vec2 st)
{
    vec3 dir = ray_dir(45.0, vec2(1, 1), st);
    vec3 eye = vec3(0.0, 0.0, 7.0);
    float dist = shortest_distance_to_surface(eye, dir, MIN_DIST, MAX_DIST);

    if (dist > MAX_DIST - EPSILON) {
        // Didn't hit anything
        return vec3(0.0, 0.0, 0.0);
    }

    // The closest point on the surface to the eyepoint along the view ray
    vec3 p = eye + dist * dir;

    vec3 K_a = vec3(0.2, 0.2, 0.2);
    vec3 K_d = vec3(0.7, 0.2, 0.2);
    vec3 K_s = vec3(1.0, 1.0, 1.0);
    float shininess = 10.0;

    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);

    return color;
}
"

class Sdf is Node
{
	init() 
	{
		super.init(Sdf.name)

		this.node_func = NodeFunction(this, CODE, "sdf", [])

        this.imports.add(Pin(this, "f_scene(p)", VAR_TYPE_FUNCTION))
        this.layout()
	}

    gen_shader(gen)
    {
        var func_idx = this.imports.count - 1
        if (this.imports[func_idx].conns.isEmpty) {
            return
        }

        var func_pin = this.imports[func_idx].conns.front().from
        var func_node = func_pin.node

        if (func_node.imports[0].conns.isEmpty) {
            return
        }
        var f_pin = func_node.imports[0].conns.front().from
        var f_node = f_pin.node
        if (f_node["node_func"] == nil) {
            return
        }

        var f_node_func = f_node.node_func
        if (f_node_func["func"] == nil) {
            return
        }

        var callee_src = f_node_func.func

        var old_func = gen.query_func(this.node_func.module, "f_scene")

        var callee = gen.create_decl_func(this.node_func.module, callee_src)
        gen.add_link_decl(callee, f_node_func.decl_name, false)

        var caller = gen.create_func(this.node_func.module, "f_scene", "float", [ "vec3" ])
        var pos = gen.get_func_param(caller, 0)

        var prev_nodes = Blueprint.get_precursor_nodes(f_node)
        for (var node in prev_nodes) {
            if (node is Parameter) {
                if (node.var_name == "p") {
                    node.var_inst = pos
                }
            }
        }        
        var args = this.get_func_args(gen, callee_src, f_node, caller)
        
        var ret = gen.func_call(caller, callee, args)
        gen.func_return_value(caller, ret)

        gen.func_replace(old_func, caller)
    }

    get_func_args(gen, callee_src, f_node, caller)
    {
        var args = []
        var names = gen.get_func_args(callee_src)
        for (var name in names)
        {
            var pin = Blueprint.query_pin(f_node.imports, name)
            args.add(f_node.node_func.calc_inst_from_pin(gen, pin, this.node_func.module, caller))
        }
        return args
    }
}