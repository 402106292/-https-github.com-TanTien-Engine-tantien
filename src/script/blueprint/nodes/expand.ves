import "blueprint.node" for Node
import "blueprint.pin" for Pin
import "blueprint.variant" for Variant, VAR_TYPE_TABLE, VAR_TYPE_ARRAY, VAR_TYPE_NUMBER, VAR_TYPE_NUMBER2, VAR_TYPE_NUMBER3, VAR_TYPE_NUMBER4
import "blueprint.blueprint" for Blueprint
import "rendergraph.variant" for VAR_TYPE_TEXTURE

class Expand is Node
{
	init() 
	{
		super.init(Expand.name)

		this.imports = [
			Pin(this, "data", [ VAR_TYPE_TABLE, VAR_TYPE_ARRAY ]),
		]

		this.export_values = []
		this.uniforms = []

		this.layout()
	}

	layout()
	{
		super.layout()

		this.style.width = 180
	}

	calc_value(idx)
	{
		return this.export_values[idx]
	}

    gen_shader(gen)
    {
    	this.uniforms = List.filled(this.exports.count, nil)
    }

	calc_inst(gen, idx, module, func) 
	{
		var value = this.export_values[idx]
		if (value.type == VAR_TYPE_TEXTURE)
		{
			if (!this.uniforms[idx]) {
				var name = this.get_unif_name(idx)
				this.uniforms[idx] = gen.add_uniform(module, name, "texture")
			}

			if (this.uniforms[idx]) {
				return gen.load(func, this.uniforms[idx])
			} else {
				return nil
			}
		}
		else if (value.type == VAR_TYPE_NUMBER)
		{
			return gen.const_float(module, value.value)
		}
		else if (value.type == VAR_TYPE_NUMBER2)
		{
			return gen.const_float2(module, value.value.x, value.value.y)	
		}
		else if (value.type == VAR_TYPE_NUMBER3)
		{
			return gen.const_float3(module, value.value.x, value.value.y, value.value.z)	
		}		
		else if (value.type == VAR_TYPE_NUMBER4)
		{
			return gen.const_float4(module, value.value.x, value.value.y, value.value.z, value.value.w)	
		}
		else
		{
			return nil
		}
	}

	bind_uniforms(prog)
	{
		for (var i in 0..this.exports.count)
		{
			var value = this.export_values[i]
			var unif = this.uniforms[i]
			if (value.type == VAR_TYPE_TEXTURE and value.value and unif)
			{
				var name = this.get_unif_name(i)
				prog.set_uniform_value([name, "sampler", [value.value.tex, "linear_clamp"]])			
			}
		}	
	}

	get_unif_name(index)
	{
		var name = ""
		
		var prev_pin = Blueprint.get_input_pin(this, 0)
		if (prev_pin) {
			name = name + prev_pin.name
		}

		name = name + "_" + this.exports[index].name	
		return name
	}

	on_connected(pin)
	{
		if (pin.is_input) {
			this.setup_data()
		}
	}

	on_disconnected(pin)
	{
		if (pin.is_input) {
			this.setup_data()
		}
	}

	setup_data()
	{
		for (var p in this.exports) {
			while (!p.conns.isEmpty) {
				Blueprint.disconnect(p.conns.front())
			}
		}
		this.exports.clear()
		this.export_values.clear()

		var data = Blueprint.calc_input_value(this, 0)
		if (!data) {
			this.layout()
			return
		}

		if (data.type == VAR_TYPE_TABLE)
		{
			for (var entry in data.value) {
				var v = Variant(entry.value)
				this.exports.add(Pin(this, entry.key, v.type))
				this.export_values.add(v)
			}
		}
		else if (data.type == VAR_TYPE_ARRAY)
		{
			for (var i in 0..data.value.count) {
				var v = Variant(data.value[i])
				this.exports.add(Pin(this, "%(i)", v.type))
				this.export_values.add(v)
			}
		}

		this.layout()

		this.uniforms = List.filled(this.exports.count, nil)
	}
}