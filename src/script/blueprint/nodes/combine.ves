import "blueprint.node" for Node
import "blueprint.pin" for Pin
import "blueprint.blueprint" for Blueprint
import "maths.vector" for Vector2, Vector3, Vector4
import "blueprint.variant" for Variant, VAR_TYPE_NUMBER, VAR_TYPE_NUMBER2, VAR_TYPE_NUMBER3, VAR_TYPE_NUMBER4

class Combine is Node
{
	init() 
	{
		super.init(Combine.name)

		this.imports = [
			Pin(this, "x",    VAR_TYPE_NUMBER),
			Pin(this, "y",    VAR_TYPE_NUMBER),
			Pin(this, "z",    VAR_TYPE_NUMBER),
			Pin(this, "w",    VAR_TYPE_NUMBER),
			Pin(this, "xy",   VAR_TYPE_NUMBER2),			
			Pin(this, "xyz",  VAR_TYPE_NUMBER3),
			Pin(this, "grey", VAR_TYPE_NUMBER),
		]
		this.exports = [
			Pin(this, "xyzw", VAR_TYPE_NUMBER4),
			Pin(this, "xyz",  VAR_TYPE_NUMBER3),
			Pin(this, "xy",   VAR_TYPE_NUMBER2),
		]

		this.layout()

		this.value = Vector4()
	}

	calc_value(idx)
	{
		var ret = [0, 0, 0, 0]

		var v_xyz = Blueprint.calc_input_value(this, 4)
		if (v_xyz) 
		{
			ret[0] = v_xyz.value.x
			ret[1] = v_xyz.value.y
			ret[2] = v_xyz.value.z
		} 
		else 
		{
			var v_grey = Blueprint.calc_input_value(this, 5)
			if (v_grey) {
				for (var i in 0..3) {
					ret[i] = v_grey.value
				}
			} else {
				for (var i in 0..3) {
					var v_num = Blueprint.calc_input_value(this, i)
					if (v_num) {
						ret[i] = v_num.value
					}
				}
			}
		}
		var v_w = Blueprint.calc_input_value(this, 3)
		if (v_w) {
			ret[3] = v_w.value
		}

		if (idx == 0) {
			return Variant(VAR_TYPE_NUMBER4, Vector4(ret[0], ret[1], ret[2], ret[3]))
		} else if (idx == 1) {
			return Variant(VAR_TYPE_NUMBER3, Vector3(ret[0], ret[1], ret[2]))
		} else if (idx == 2) {
			return Variant(VAR_TYPE_NUMBER2, Vector2(ret[0], ret[1]))
		}

		return nil		
	}

	calc_inst(gen, idx, module, func)
	{
		var x = Blueprint.calc_input_inst(gen, this, "x", module, func)
		if (!x) {
			x = gen.const_float(module, 0.0)
		}
		var y = Blueprint.calc_input_inst(gen, this, "y", module, func)
		if (!y) {
			y = gen.const_float(module, 0.0)
		}
		var z = Blueprint.calc_input_inst(gen, this, "z", module, func)
		if (!z) {
			z = gen.const_float(module, 0.0)
		}
		var w = Blueprint.calc_input_inst(gen, this, "w", module, func)
		if (!w) {
			w = gen.const_float(module, 0.0)
		}
		var xy = Blueprint.calc_input_inst(gen, this, "xy", module, func)
		if (xy) {
			x = gen.compose_extract(func, xy, 0)
			y = gen.compose_extract(func, xy, 1)
		}		
		var xyz = Blueprint.calc_input_inst(gen, this, "xyz", module, func)
		if (xyz) {
			x = gen.compose_extract(func, xyz, 0)
			y = gen.compose_extract(func, xyz, 1)
			z = gen.compose_extract(func, xyz, 2)
		}
		var grey = Blueprint.calc_input_inst(gen, this, "grey", module, func)
		if (grey) {
			x = grey
			y = grey
			z = grey
		}

		if (idx == 0) {
			return gen.compose_float4(func, x, y, z, w)
		} else if (idx == 1) {
			return gen.compose_float3(func, x, y, z)
		} else if (idx == 2) {
			return gen.compose_float2(func, x, y)
		}

		return nil
	}	
}