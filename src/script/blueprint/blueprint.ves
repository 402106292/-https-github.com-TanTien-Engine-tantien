import "blueprint.connecting" for Connecting

class Blueprint
{
	static topo_sort(nodes)
	{
		// prepare
		var in_deg = List.filled(nodes.count, 0)
		var out_nodes = []
		for (var i = 0; i < nodes.count; i = i + 1) {
			out_nodes.add([])
		}	
		for (var i = 0; i < nodes.count; i = i + 1)
		{
			for (var pin in nodes[i].imports)
			{
				for (var conn in pin.conns)
				{
					for (var j = 0; j < nodes.count; j = j + 1)
					{
						if (nodes[j] == conn.from.node) {
							in_deg[i] = in_deg[i] + 1
							out_nodes[j].add(i)
							// todo break
							// break;
						}
					}
				}
			}
		}

		// sort
		var st = []
		for (var i = 0; i < in_deg.count; i = i + 1)
		{
			if (in_deg[i] == 0) {
				st.add(i)
			}
		}
		var ret = []
		while (st.count > 0)
		{
			var v = st[st.count - 1]
			st.removeAt(st.count - 1)
			ret.add(nodes[v])
			for (var i in out_nodes[v])
			{
				in_deg[i] = in_deg[i] - 1
				if (in_deg[i] == 0) {
					st.add(i)
				}
			}
		}

		return ret
	}

	static get_precursor_nodes(root)
	{
		var nodes = Set.new()
		var buf = []
		buf.add(root)
		while (!buf.isEmpty)
		{
			var n = buf[buf.count - 1]
			buf.removeAt(buf.count - 1)

			nodes.add(n)
			for (var pin in n.imports) {
				if (!pin.stop_port_pass) {
					for (var conn in pin.conns) {
						if (!conn.from.stop_port_pass) {
							buf.add(conn.from.node)
						}
					}
				}
			}
		}
		return nodes
	}

	static get_successor_nodes(root)
	{
		var nodes = Set.new()
		var buf = []
		buf.add(root)
		while (!buf.isEmpty)
		{
			var n = buf[buf.count - 1]
			buf.removeAt(buf.count - 1)

			nodes.add(n)
			for (var pin in n.exports) {
				if (!pin.stop_port_pass) {
					for (var conn in pin.conns) {
						if (!conn.to.stop_port_pass) {
							buf.add(conn.to.node)
						}
					}
				}
			}
		}
		return nodes
	}

	static connect(from, to)
	{
		// input pin only has one conn
		if (!to.conns.isEmpty) {
			Blueprint.disconnect(to.conns.front())
		}

		var conn = Connecting(from, to)
		from.conns.add(conn)
		to.conns.add(conn)
		conn.update()
	}

	static query_pin(pins, slot)
	{
		if (slot is Num) {
			if (slot >= 0 and slot < pins.count) {
				return pins[slot]
			}
		} else if (slot is String) {
			for (var p in pins) {
				if (p.name == slot) {
					return p
				}
			}
		}
		return nil
	}

	static connect(f_node, f_pin, t_node, t_pin)
	{
		var f = this.query_pin(f_node.exports, f_pin)
		var t = this.query_pin(t_node.imports, t_pin)
		if (f and t) {
			this.connect(f, t)
		} else {
			System.print("connect fail %(f_pin) -> %(t_pin), %(f) %(t)")
		}
	}

	static disconnect(conn)
	{
		conn.from.conns.remove(conn)
		conn.to.conns.remove(conn)
		conn.update()
	}

	static get_input_pin(curr_node, input_slot)
	{
		var pin = this.query_pin(curr_node.imports, input_slot)
		if (pin.conns.isEmpty) {
			return nil
		} else {
			return pin.conns.front().from
		}
	}

	static get_input_node(curr_node, input_slot)
	{
		var pin = this.get_input_pin(curr_node, input_slot)
		if (pin) {
			return pin.node
		}
		return nil
	}

	static calc_input_value(curr_node, input_slot)
	{
		var pin = this.query_pin(curr_node.imports, input_slot)
		if (pin.conns.isEmpty) {
			return nil
		} else {
			var f_pin = pin.conns.front().from
			var f_node = f_pin.node
			return f_node.calc(f_pin.slot_idx)
		}	
	}

	static get_first_connect_pin(pin)
	{
		if (pin.conns.isEmpty) {
			return nil
		}
		if (pin.is_input) {
			return pin.conns.front().from
		} else {
			return pin.conns.front().to
		}
	}

	static is_out_conns_empty(node)
	{
		for (var p in node.exports) {
			if (!p.conns.isEmpty) {
				return false
			}
		}
		return true
	}
}