import "blueprint.blueprint" for Blueprint
import "blueprint.variant" for Variant, VAR_TYPE_BOOLEAN, VAR_TYPE_INTEGER, VAR_TYPE_NUMBER, VAR_TYPE_NUMBER2, VAR_TYPE_NUMBER3, VAR_TYPE_NUMBER4, VAR_TYPE_MATRIX2, VAR_TYPE_MATRIX3, VAR_TYPE_MATRIX4, VAR_TYPE_FUNCTION
import "blueprint.node_param" for NodeParam
import "blueprint.node_helper" for NodeHelper
import "render" for Render
import "shadergraph.nodes.uniform" for Uniform
import "shader" for SpirvGenTwo, ShaderTools
import "rendergraph.variant" for VAR_TYPE_TEXTURE
import "rendergraph.nodes.texture" for Texture

class NodeFunction
{
	init(node, code, func_name, params)
	{
		this.init(node, code, "glsl", func_name, params)
	}

	init(node, code, lang, func_name, params)
	{
		if (lang == "hlsl") {
			code = ShaderTools.hlsl2glsl("pixel", code, func_name)
			lang = "glsl"
		}

		this.rename_ubo = code.contains("__UBO__")
		if (this.rename_ubo) {
			code = code.replace("__UBO__", "UBO_" + node.name)
		}

		this.num_params = NodeHelper.init_pins_from_code(node, code, lang, func_name)
		
		for (var param in params)
		{
			var node_param = NodeParam(param[0], param[1])
			node.params.add(node_param)
			if (param.count > 2) {
				for (var entry in param[2]) {
					node_param[entry.key] = entry.value
				}
			}
		}

		this.node = node
		this.code = code
		this.lang = lang
		this.func_name = func_name
		this.decl_name = "bp_" + node.name

		this.module = nil

		this.uniforms = []

		node.layout()
	}

	has_uniforms()
	{
		return this.num_params < this.node.imports.count
	}

	shader_gen(ctx)
	{
		this.module = ctx.gen.add_module("pixel", this.code, this.lang, this.decl_name, this.func_name)

		this.func = this.module.query_func(this.func_name)

		ctx.gen.add_link_decl(this.func, this.decl_name, true)

		this.uniforms.clear()
	}

	calc_value_inst(type, value, module)
	{
		if (value)
		{
			if (type == VAR_TYPE_BOOLEAN) {
				return module.const_bool(value)
			} else if (type == VAR_TYPE_INTEGER) {
				return module.const_int(value)
			} else if (type == VAR_TYPE_NUMBER) {
				return module.const_float(value)
			} else if (type == VAR_TYPE_NUMBER2) {
				return module.const_float2(value.x, value.y)
			} else if (type == VAR_TYPE_NUMBER3) {
				return module.const_float3(value.x, value.y, value.z)
			} else if (type == VAR_TYPE_NUMBER4) {
				return module.const_float4(value.x, value.y, value.z, value.w)
			}
		}
		else
		{
			if (type == VAR_TYPE_BOOLEAN) {
				return module.const_bool(false)
			} else if (type == VAR_TYPE_INTEGER) {
				return module.const_int(0)
			} else if (type == VAR_TYPE_NUMBER) {
				return module.const_float(0.0)
			} else if (type == VAR_TYPE_NUMBER2) {
				return module.const_float2(0.0, 0.0)
			} else if (type == VAR_TYPE_NUMBER3) {
				return module.const_float3(0.0, 0.0, 0.0)
			} else if (type == VAR_TYPE_NUMBER4) {
				return module.const_float4(0.0, 0.0, 0.0, 0.0)
			} else if (type == VAR_TYPE_MATRIX2) {
				return module.const_mat2([1.0, 0.0, 1.0, 0.0])
			} else if (type == VAR_TYPE_MATRIX3) {
				return module.const_mat3([1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0])
			} else if (type == VAR_TYPE_MATRIX4) {
				return module.const_mat4([1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0])
			}
		}
		return nil
	}	

	calc_inst_from_pin(pin, ctx)
	{
		var inst = Blueprint.calc_input_inst(this.node, pin.name, ctx)
		if (inst) {
			return inst
		}

		var val = Blueprint.calc_input_value(this.node, pin.slot_idx)
		if (val) {
			inst = this.calc_value_inst(pin.type, val.value, ctx.module)
		} else {			
			var param = this.node.query_param(pin.name)
			if (param) {
				inst = this.calc_value_inst(pin.type, param.value, ctx.module)
			} else {
				inst = this.calc_value_inst(pin.type, nil, ctx.module)
			}
		}

		return inst
	}

	calc_inst(idx, ctx)
	{
		if (!this["func"]) {
			return nil
		}

		// prepare uniforms
		for (var i in this.num_params..this.node.imports.count)
		{
			var prev_pin = Blueprint.get_input_pin(this.node, i)
			var pin = this.node.imports[i]
			if (prev_pin and prev_pin.node is Texture) {			
				prev_pin.node.init_unif_name(pin.name)
				Blueprint.calc_input_inst(this.node, i, ctx)
			}

			var unif = Uniform()
			unif.dummy = true
			if (prev_pin) {
				Blueprint.connect(prev_pin, unif.imports[0])
			}
			if (this.rename_ubo) {
				unif.unif_name = "u_" + this.node.name + "." + this.node.imports[i].name
			} else {
				unif.unif_name = this.node.imports[i].name
			}
			this.uniforms.add(unif)
		}

		// func call
		var callee = ctx.module.create_decl_func(this.func)
		ctx.gen.add_link_decl(callee, this.decl_name, false)

		var params = []
		for (var i in 0..this.num_params)
		{
			var pin = this.node.imports[i]
			if (pin.type != VAR_TYPE_FUNCTION) 
			{
				var inst = this.calc_inst_from_pin(pin, ctx)
				if (!inst) {
					return nil
				}

				// todo: check if param need a var (in/out)
				var type = inst.get_type()
				var inst_var = nil
				if (type == "float") {
					inst_var = ctx.func.variable_float()
				} else if (type == "float_2") {
					inst_var = ctx.func.variable_float2()
				} else if (type == "float_3") {
					inst_var = ctx.func.variable_float3()
				} else if (type == "float_4") {
					inst_var = ctx.func.variable_float4()
				}
				if (inst_var) 
				{
					ctx.bb.store(inst_var, inst)
					params.add(inst_var)
				}
				else
				{
					params.add(inst)
				}
			}
		}
		return ctx.func.call(callee, params)
	}

	bind_uniforms(prog)
	{
		if (this.uniforms.isEmpty) {
			return
		}

		for (var i in this.num_params..this.node.imports.count)
		{	
			var unif = this.uniforms[i - this.num_params]			

			var val = unif.bind_uniforms(prog)

			var in_node = Blueprint.get_input_node(this.node, i)
			if (this.node.imports[i].type == VAR_TYPE_TEXTURE) 
			{
				var v_tex = Blueprint.calc_input_value(this.node, i)
				if (v_tex) {
					var tex = v_tex.value.tex
					var smp = v_tex.value.sampler
					prog.set_uniform_value([this.node.imports[i].name, "sampler", [tex, smp]])
				}
			}

			var param = this.node.query_param(this.node.imports[i].name)
			if (param)
			{
				if (val) {
					param.set_value(val.value)
				} else {
					unif.bind_unif_val(prog, Variant(param.value))
				}
			}
		}
	}
}