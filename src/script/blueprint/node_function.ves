import "blueprint.blueprint" for Blueprint
import "blueprint.variant" for Variant, VAR_TYPE_BOOLEAN, VAR_TYPE_INTEGER, VAR_TYPE_NUMBER, VAR_TYPE_NUMBER2, VAR_TYPE_NUMBER3, VAR_TYPE_NUMBER4, VAR_TYPE_MATRIX2, VAR_TYPE_MATRIX3, VAR_TYPE_MATRIX4, VAR_TYPE_FUNCTION
import "blueprint.node_param" for NodeParam
import "blueprint.node_helper" for NodeHelper
import "render" for Render
import "shadergraph.nodes.uniform" for Uniform
import "shader" for SpirvGenTwo

class NodeFunction
{
	init(node, code, func_name, params)
	{
		this.init(node, code, "glsl", func_name, params)
	}

	init(node, code, lang, func_name, params)
	{
		this.rename_ubo = code.contains("__UBO__")
		if (this.rename_ubo) {
			code = code.replace("__UBO__", "UBO_" + node.name)
		}

		this.num_params = NodeHelper.init_pins_from_code(node, code, lang, func_name)
		
		for (var param in params)
		{
			var node_param = NodeParam(param[0], param[1])
			node.params.add(node_param)
			if (param.count > 2) {
				for (var entry in param[2]) {
					node_param[entry.key] = entry.value
				}
			}
		}

		this.node = node
		this.code = code
		this.lang = lang
		this.func_name = func_name
		this.decl_name = "bp_" + node.name

		this.module = nil

		this.uniforms = []

		node.layout()
	}

	has_uniforms()
	{
		return this.num_params < this.node.imports.count
	}

	gen_shader(gen)
	{
		this.module = gen.add_module("pixel", this.code, this.lang, this.decl_name, this.func_name)

		this.func = gen.query_func(this.module, this.func_name)

		gen.add_link_decl(this.func, this.decl_name, true)

		this.uniforms.clear()
	}

	calc_value_inst(gen, module, type, value)
	{
		if (value)
		{
			if (type == VAR_TYPE_BOOLEAN) {
				return gen.const_bool(module, value)
			} else if (type == VAR_TYPE_INTEGER) {
				return gen.const_int(module, value)
			} else if (type == VAR_TYPE_NUMBER) {
				return gen.const_float(module, value)
			} else if (type == VAR_TYPE_NUMBER2) {
				return gen.const_float2(module, value.x, value.y)
			} else if (type == VAR_TYPE_NUMBER3) {
				return gen.const_float3(module, value.x, value.y, value.z)
			} else if (type == VAR_TYPE_NUMBER4) {
				return gen.const_float4(module, value.x, value.y, value.z, value.w)
			}
		}
		else
		{
			if (type == VAR_TYPE_BOOLEAN) {
				return gen.const_bool(module, false)
			} else if (type == VAR_TYPE_INTEGER) {
				return gen.const_int(module, 0)
			} else if (type == VAR_TYPE_NUMBER) {
				return gen.const_float(module, 0.0)
			} else if (type == VAR_TYPE_NUMBER2) {
				return gen.const_float2(module, 0.0, 0.0)
			} else if (type == VAR_TYPE_NUMBER3) {
				return gen.const_float3(module, 0.0, 0.0, 0.0)
			} else if (type == VAR_TYPE_NUMBER4) {
				return gen.const_float4(module, 0.0, 0.0, 0.0, 0.0)
			} else if (type == VAR_TYPE_MATRIX2) {
				return gen.const_mat2(module, [1.0, 0.0, 1.0, 0.0])
			} else if (type == VAR_TYPE_MATRIX3) {
				return gen.const_mat3(module, [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0])
			} else if (type == VAR_TYPE_MATRIX4) {
				return gen.const_mat4(module, [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0])
			}
		}
		return nil
	}	

	calc_inst_from_pin(gen, pin, module, func)
	{
		var inst = Blueprint.calc_input_inst(gen, this.node, pin.name, module, func)
		if (inst) {
			return inst
		}

		var val = Blueprint.calc_input_value(this.node, pin.slot_idx)
		if (val) {
			inst = this.calc_value_inst(gen, module, pin.type, val.value)
		} else {			
			var param = this.node.query_param(pin.name)
			if (param) {
				inst = this.calc_value_inst(gen, module, pin.type, param.value)
			} else {
				inst = this.calc_value_inst(gen, module, pin.type, nil)
			}
		}

		return inst
	}

	calc_inst(gen, idx, module, func)
	{
		if (!this["func"]) {
			return nil
		}

		// prepare uniforms
		for (var i in this.num_params..this.node.imports.count)
		{
			var unif = Uniform()
			unif.dummy = true
			var prev_pin = Blueprint.get_input_pin(this.node, i)
			if (prev_pin) {
				Blueprint.connect(prev_pin, unif.imports[0])
			}
			if (this.rename_ubo) {
				unif.unif_name = "u_" + this.node.name + "." + this.node.imports[i].name
			} else {
				unif.unif_name = this.node.imports[i].name
			}
			this.uniforms.add(unif)
		}

		// func call
		var callee = gen.create_decl_func(module, this.func)
		gen.add_link_decl(callee, this.decl_name, false)

		var params = []
		for (var i in 0..this.num_params)
		{
			var pin = this.node.imports[i]
			if (pin.type != VAR_TYPE_FUNCTION) 
			{
				var inst = this.calc_inst_from_pin(gen, pin, module, func)
				if (!inst) {
					return nil
				}

				// todo: check if param need a var (in/out)
				var type = SpirvGenTwo.get_type(inst)
				var inst_var = nil
				if (type == "float") {
					inst_var = gen.variable_float(func)
				} else if (type == "float_2") {
					inst_var = gen.variable_float2(func)
				} else if (type == "float_3") {
					inst_var = gen.variable_float3(func)
				} else if (type == "float_4") {
					inst_var = gen.variable_float4(func)
				}
				if (inst_var) 
				{
					gen.store(func, inst_var, inst)
					params.add(inst_var)
				}
				else
				{
					params.add(inst)
				}
			}
		}
		return gen.func_call(func, callee, params)
	}

	bind_uniforms(prog)
	{
		if (this.uniforms.isEmpty) {
			return
		}

		for (var i in this.num_params..this.node.imports.count)
		{	
			var unif = this.uniforms[i - this.num_params]			
			var val = unif.bind_uniforms(prog)
			var param = this.node.query_param(this.node.imports[i].name)
			if (param)
			{
				if (val) {
					param.set_value(val.value)
				} else {
					unif.bind_unif_val(prog, Variant(param.value))
				}
			}
		}
	}
}