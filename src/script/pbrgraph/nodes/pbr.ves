import "blueprint.node" for Node
import "blueprint.pin" for Pin
import "blueprint.variant" for Variant
import "rendergraph.variant" for VAR_TYPE_SHADER
import "rendergraph.variates.shader" for Shader as var_Shader
import "rendergraph.components.shader_uniforms" for ShaderUniforms
import "render" for Shader

var DEFAULT_VS = "
#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;

out vec2 TexCoords;
out vec3 fragpos;
out vec3 normal;

uniform UBO
{
	mat4 model;
	mat4 view;
	mat4 projection;
};

void main()
{
    TexCoords = aTexCoords;

	vec4 pos = model * vec4(aPos, 1.0);
	fragpos = vec3(pos.xyz) / pos.w;

	normal = normalize(vec3(model * vec4(aNormal.xyz, 0.0)));

    gl_Position = projection * view * pos;
}
"

var DEFAULT_FS = "
// https://github.com/bghgary/glTF-WebGL-PBR
#version 330 core
out vec4 FragColor;

in vec2 TexCoords;
in vec3 fragpos;
in vec3 normal;

uniform UBO
{
	uniform vec3 light_pos;
	uniform vec3 cam_pos;
};

uniform sampler2D texture_diffuse1;
uniform sampler2D tex_normal;
uniform sampler2D tex_occlusion;
uniform sampler2D tex_emissive;
uniform sampler2D tex_metallic_roughness;

const float M_PI = 3.141592653589793;
const float c_MinRoughness = 0.04;

#define MANUAL_SRGB
vec4 SRGBtoLINEAR(vec4 srgbIn)
{
#ifdef MANUAL_SRGB
#ifdef SRGB_FAST_APPROXIMATION
    vec3 linOut = pow(srgbIn.xyz,vec3(2.2));
#else //SRGB_FAST_APPROXIMATION
    vec3 bLess = step(vec3(0.04045),srgbIn.xyz);
    vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );
#endif //SRGB_FAST_APPROXIMATION
    return vec4(linOut,srgbIn.w);;
#else //MANUAL_SRGB
    return srgbIn;
#endif //MANUAL_SRGB
}

#define HAS_NORMALS
#define HAS_NORMALMAP
vec3 calc_normal()
{
    // Retrieve the tangent space matrix
#ifndef HAS_TANGENTS
    vec3 pos_dx = dFdx(fragpos);
    vec3 pos_dy = dFdy(fragpos);
    vec3 tex_dx = dFdx(vec3(TexCoords, 0.0));
    vec3 tex_dy = dFdy(vec3(TexCoords, 0.0));
    vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);

#ifdef HAS_NORMALS
    vec3 ng = normalize(normal);
#else
    vec3 ng = cross(pos_dx, pos_dy);
#endif

    t = normalize(t - ng * dot(ng, t));
    vec3 b = normalize(cross(ng, t));
    mat3 tbn = mat3(t, b, ng);
#else // HAS_TANGENTS
    mat3 tbn = v_TBN;
#endif

#ifdef HAS_NORMALMAP
    vec3 n = texture(tex_normal, TexCoords).rgb;
    n = normalize(tbn * (2.0 * n - 1.0));
#else
    // The tbn matrix is linearly interpolated, so we need to re-normalize
    vec3 n = normalize(tbn[2].xyz);
#endif

    return n;
}

vec3 diffuse(vec3 diffuse_color)
{
    return diffuse_color / M_PI;
}

vec3 specular_reflection(vec3 reflectance0, vec3 reflectance90, float VdotH)
{
    return reflectance0 + (reflectance90 - reflectance0) * pow(clamp(1.0 - VdotH, 0.0, 1.0), 5.0);
}

float geometric_occlusion(float NdotL, float NdotV, float alpha_roughness)
{
    float r = alpha_roughness;
    float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));
    float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));
    return attenuationL * attenuationV;
}

float microfacet_distribution(float NdotH, float alpha_roughness)
{
    float roughnessSq = alpha_roughness * alpha_roughness;
    float f = (NdotH * roughnessSq - NdotH) * NdotH + 1.0;
    return roughnessSq / (M_PI * f * f);
}

void main()
{    
	vec4 base_color = SRGBtoLINEAR(texture(texture_diffuse1, TexCoords));

    vec4 metallic_roughness = texture(tex_metallic_roughness, TexCoords);
    float perceptual_roughness = metallic_roughness.g;
    float metallic = metallic_roughness.b;

    perceptual_roughness = clamp(perceptual_roughness, c_MinRoughness, 1.0);
	float alpha_roughness = perceptual_roughness * perceptual_roughness;

    vec3 f0 = vec3(0.04);
    vec3 diffuse_color = base_color.rgb * (vec3(1.0) - f0);
    diffuse_color *= 1.0 - metallic;
    vec3 specular_color = mix(f0, base_color.rgb, metallic);

    float reflectance = max(max(specular_color.r, specular_color.g), specular_color.b);
    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
    vec3 specularEnvironmentR0 = specular_color.rgb;
    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;

    vec3 n = calc_normal();
    vec3 v = normalize(cam_pos - fragpos);
    vec3 l = normalize(light_pos - fragpos);
    vec3 h = normalize(l + v);
    vec3 reflection = -normalize(reflect(v, n));

    float NdotL = clamp(dot(n, l), 0.001, 1.0);
    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);
    float NdotH = clamp(dot(n, h), 0.0, 1.0);
    float LdotH = clamp(dot(l, h), 0.0, 1.0);
    float VdotH = clamp(dot(v, h), 0.0, 1.0);

    vec3 F = specular_reflection(specularEnvironmentR0, specularEnvironmentR90, VdotH);
    float G = geometric_occlusion(NdotL, NdotV, alpha_roughness);
    float D = microfacet_distribution(NdotH, alpha_roughness);

    // todo
    vec3 light_color = vec3(1.0);

    vec3 diffuse_contrib = (1.0 - F) * diffuse(diffuse_color);
    vec3 spec_contrib = F * G * D / (4.0 * NdotL * NdotV);
    vec3 color = NdotL * light_color * (diffuse_contrib + spec_contrib);

    float ao = texture(tex_occlusion, TexCoords).r;
    color = color * ao;

	vec3 emissive = SRGBtoLINEAR(texture(tex_emissive, TexCoords)).rgb;
	color += emissive;

	FragColor = vec4(pow(color,vec3(1.0/2.2)), base_color.a);
}
"

class Pbr is Node
{
	init() 
	{
		super.init(Pbr.name)

		this.exports = [
			Pin(this, "out", VAR_TYPE_SHADER)
		]

		this.layout()

		this.vs = DEFAULT_VS
		this.fs = DEFAULT_FS

		this.shader = var_Shader(this)
		this.dirty = true

		this.uniforms = []
		this.fold_array = true
	}

	calc_value(idx)
	{
		return Variant(VAR_TYPE_SHADER, this.shader)
	}

	execute() 
	{
		if (!this.dirty) {
			return
		}

		this.shader.prog = Shader.init(this.vs, "", "", "", this.fs)

		if (this.shader.prog)
		{
			var uniforms = []
			ShaderUniforms.get_shader_uniforms("vertex", this.vs,  uniforms)
			ShaderUniforms.get_shader_uniforms("pixel",  this.fs,  uniforms)
			this.uniforms = uniforms
			for (var unif in this.uniforms) {
				ShaderUniforms.add_uniform_to_imports(this, unif)
			}

			this.layout()
		}

		this.dirty = false
	}

	to_string(name) 
	{
		return "
%(name).execute()
"
	}
}