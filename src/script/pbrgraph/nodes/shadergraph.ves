import "blueprint.node" for Node
import "blueprint.pin" for Pin
import "blueprint.variant" for Variant, VAR_TYPE_NUMBER4
import "blueprint.blueprint" for Blueprint
import "blueprint.node_layout" for DEFAULT_HEIGHT
import "rendergraph.variant" for VAR_TYPE_SHADER
import "rendergraph.variates.shader" for Shader as var_Shader
import "rendergraph.components.shader_uniforms" for ShaderUniforms
import "shader" for ShaderGen
import "render" for Shader
import "gui" for GUI

var DEFAULT_VS = "
#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;

out vec2 TexCoord;
out vec3 fragpos;
out vec3 normal;

uniform UBO
{
	mat4 model;
	mat4 view;
	mat4 projection;
};

void main()
{
    TexCoord = aTexCoords;

	vec4 pos = model * vec4(aPos, 1.0);
	fragpos = vec3(pos.xyz) / pos.w;

	normal = normalize(vec3(model * vec4(aNormal.xyz, 0.0)));

    gl_Position = projection * view * pos;
}
"

class Shadergraph is Node
{
	init() 
	{
		super.init(Shadergraph.name)

		this.imports = [
			Pin(this, "rgba", VAR_TYPE_NUMBER4)
		]
		this.exports = [
			Pin(this, "shader", VAR_TYPE_SHADER)
		]

		this.vs = DEFAULT_VS
//		this.fs = DEFAULT_FS

		this.shader = var_Shader(this)
		this.dirty = true

		//this.uniforms = []
		this.fold_array = true		

		var uniforms = []
		ShaderUniforms.get_shader_uniforms("vertex", this.vs,  uniforms)
		//ShaderUniforms.get_shader_uniforms("pixel",  this.fs,  uniforms)
		this.uniforms = uniforms
		for (var unif in this.uniforms) {
			ShaderUniforms.add_uniform_to_imports(this, unif)
		}

		this.layout()
	}

	calc(idx)
	{
		return Variant(VAR_TYPE_SHADER, this.shader)
	}

	layout() 
	{
		super.layout()

		this.style.height = this.style.height + DEFAULT_HEIGHT
	}
	
	execute() 
	{
		if (!this.dirty) {
			return
		}

		this.rebuild_shader()

		this.dirty = false
	}

	rebuild_shader()
	{
		var gen = ShaderGen.init()

		var prev_nodes = Blueprint.get_precursor_nodes(this)
		var list = Blueprint.topo_sort(prev_nodes)
		for (var node in list) 
		{
			if (node["node_func"]) {
				node.node_func.gen_shader(gen)
			} 
			if (node.has_method("gen_shader(_)")) {
				node.gen_shader(gen)
			}
		}

		this.shader.prog = Shader.init(DEFAULT_VS, "", "", "", gen)
	}

	draw_gui(ctx)
	{
		var dirty = false

		var x = this.pos.x - this.style.width * 0.5
		var y = this.pos.y + this.style.height* 0.5 - this.calc_panel_height() - DEFAULT_HEIGHT

		if (GUI.button(ctx, "rebuild", x, y, 0, 0)) {
			this.dirty = true
		}

		return dirty
	}

	gen_shader(gen)
	{
		gen.import_all()

		var frag_col = gen.add_output("FragColor", "vec4")

		var module = gen.get_main_module()
		var func = gen.get_main_func()
		var rgba = Blueprint.calc_input_inst(gen, this, "rgba", module, func)
		if (!rgba) {
			var r = gen.const_float(module, 0.0)
			var g = gen.const_float(module, 0.0)
			var b = gen.const_float(module, 0.0)
			var a = gen.const_float(module, 1.0)
			rgba = gen.compose_float4(func, r, g, b, a)
		}
		gen.store(func, frag_col, rgba)

		gen.func_return(func)

		gen.finish_main()
	}

	bind_uniforms()
	{
		var prog = this.shader.prog
		if (prog)
		{
			var prev_nodes = Blueprint.get_precursor_nodes(this)
			for (var node in prev_nodes)
			{
				if (node.has_method("bind_uniforms(_)")) {
					node.bind_uniforms(prog)
				}
			}
		}
	}
}