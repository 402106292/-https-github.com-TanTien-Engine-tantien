import "blueprint.node" for Node
import "blueprint.pin" for Pin
import "blueprint.variant" for Variant
import "render" for Cubemap as tt_Cubemap
import "rendergraph.variant_type" for VarTexture, VAR_TYPE_TEXTURE, VAR_TYPE_ARRAY

class Cubemap is Node
{
	init() 
	{
		super.init(Cubemap.name)

		this.imports = [
			Pin(this, "right",  VAR_TYPE_TEXTURE),
			Pin(this, "left",   VAR_TYPE_TEXTURE),
			Pin(this, "top",    VAR_TYPE_TEXTURE),
			Pin(this, "bottom", VAR_TYPE_TEXTURE),
			Pin(this, "front",  VAR_TYPE_TEXTURE),
			Pin(this, "back",   VAR_TYPE_TEXTURE)
		]
		this.exports = [
			Pin(this, "tex",    VAR_TYPE_TEXTURE),
			Pin(this, "6texes", VAR_TYPE_ARRAY)
		]

		this.layout()

		this.tex = nil

		this.width  = 0
		this.height = 0
		this.format = "rgba8"	
	}

	calc(idx)
	{
		if (!this.tex)
		{
			var cube_texs = []
			for (var p in this.imports) 
			{
				var conns = p.conns
				if (!conns.isEmpty) 
				{
					var f_pin = conns.front().from
					var v = f_pin.node.calc(f_pin.slot_idx)
					if (v and v.type == VAR_TYPE_TEXTURE) {
						cube_texs.add(v.value.tex)
					}
				}
			}
			if (cube_texs.count == 6) {
				this.tex = tt_Cubemap.init(cube_texs)
			}
		}

		if (idx == 0) 
		{
			var ret = VarTexture()
			ret.tex = this.tex
			return Variant(VAR_TYPE_TEXTURE, ret)			
		} 
		else if (idx == 1) 
		{
			var list = []
			for (var i in 0..6) 
			{
				var tex = VarTexture()
				tex.tex = this.tex

				tex.cubemap_idx = i
				list.add(tex)
			}
			return Variant(VAR_TYPE_ARRAY, list)
		}
	}

	toString(name) 
	{
		return "
%(name).init_texture(%(this.width), %(this.height), \"%(this.format)\")
"
	}

	init_texture(width, height, format)
	{
		this.width  = width
		this.height = height
		this.format = format

		if (width == 0 or height == 0) {
			return
		}

		this.tex = tt_Cubemap.init(width, height, format)
	}
}