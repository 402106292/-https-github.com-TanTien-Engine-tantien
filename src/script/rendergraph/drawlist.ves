import "blueprint.blueprint" for Blueprint
import "blueprint.nodes.for" for For
import "blueprint.nodes.for_each" for ForEach
import "blueprint.nodes.subgraph" for Subgraph
import "rendergraph.nodes.draw" for Draw
import "rendergraph.nodes.compute" for Compute
import "rendergraph.nodes.pass" for Pass

class Drawlist
{
	init(nodes)
	{
		this.for_each = nil

		this.lists = []
		this.build_lists(nodes, this.lists)
	}

	build_lists(nodes, lists)
	{
		for (var node in nodes) 
		{
			if (node is Pass and node.exports[0].conns.isEmpty) {
				node.rebuild_drawlist()
				lists.add([ node ])
			} else if ((node is Draw or node is Compute) and node.exports[0].conns.isEmpty) {
				var prev_nodes = Blueprint.get_precursor_nodes(node)
				var list = Blueprint.topo_sort(prev_nodes)
				lists.add(list)
			} else if (node is For) {
				node.rebuild_exec_list()
			} else if (node is ForEach) {
				this.for_each = node
			} else if (node is Subgraph) {
				var sub_nodes = []
				for (var item in node.all_items) {
					sub_nodes.add(item[0])
				}
				this.build_lists(sub_nodes, lists)
			}
		}

		// fixme: for terraingraph
		if (this.lists.isEmpty) {
			var list = Blueprint.topo_sort(nodes)
			lists.add(list)
		}
	}

	draw_impl()
	{
		for (var list in this.lists) 
		{
			var skip = false
			if (!list.isEmpty and list[list.count - 1] is Draw and list[list.count - 1].skip) {
				skip = true
			}
			if (!skip)
			{
				for (var node in list) {
					if (node.has_method("execute()")) {
						node.execute()
					}
				}
			}
		}
	}

	draw()
	{
		if (this.for_each)
		{
			this.for_each.reset_ptr()
			while (true)
			{
				this.draw_impl()
				if (!this.for_each.advance()) {
					return
				}

				return
			}
		}
		else
		{
			this.draw_impl()
		}
	}
}