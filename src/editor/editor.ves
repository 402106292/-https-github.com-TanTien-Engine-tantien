import "scene.scene" for Scene
import "scene.scene_stack" for SceneStack
import "graphics.camera2d" for Camera2D as tt_Camera2D
import "gui" for GUI, Context, MOUSE_LEFT, MOUSE_RIGHT, MOUSE_DOWN, MOUSE_UP, MOUSE_MOVE, MOUSE_DRAG
import "blueprint.edit_op" for EditOP as BlueprintEditOP
import "blueprint.node_op" for NodeOP
import "blueprint.blueprint" for Blueprint
import "blueprint.variant" for VAR_TYPE_ANY
import "maths.vector" for Vector2
import "graphics" for Graphics, Textbox
import "scene.node" for Node as SceneNode
import "scene.components.boundingbox2" for BoundingBox2
import "scene.components.transform2" for Transform2
import "io" for IO
import "filesystem" for Filesystem
import "editor.operators.node2d_translate" for Node2dTranslate
import "editor.node_cache" for NODE_CACHE
import "system" for System as tt_System
import "maths" for Matrix44
import "image" for ImageData
import "render" for Render, Framebuffer, RenderBuffer

import "blueprint.nodes.number" for Number
import "blueprint.nodes.number2" for Number2
import "blueprint.nodes.number3" for Number3
import "blueprint.nodes.number4" for Number4
import "blueprint.nodes.combine" for Combine
import "blueprint.nodes.time" for Time
import "blueprint.nodes.sin" for Sin
import "blueprint.nodes.cos" for Cos
import "blueprint.nodes.radians" for Radians
import "blueprint.nodes.add" for Add
import "blueprint.nodes.subtract" for Subtract
import "blueprint.nodes.multiply" for Multiply
import "blueprint.nodes.divide" for Divide
import "blueprint.nodes.matrix" for Matrix
import "blueprint.nodes.translate" for Translate
import "blueprint.nodes.rotate" for Rotate
import "blueprint.nodes.scale" for Scale
import "blueprint.nodes.camera2d" for Camera2D
import "blueprint.nodes.camera3d" for Camera3D
import "blueprint.nodes.perspective" for Perspective
import "blueprint.nodes.orthographic" for Orthographic
import "blueprint.nodes.lookat" for LookAt
import "blueprint.nodes.for" for For
import "blueprint.nodes.array" for Array
import "blueprint.nodes.print" for Print
import "blueprint.nodes.clamp" for Clamp
import "blueprint.nodes.fetch" for Fetch
import "blueprint.nodes.custom" for Custom
import "blueprint.nodes.input" for Input
import "blueprint.nodes.output" for Output
import "blueprint.nodes.property" for Property
import "blueprint.nodes.subgraph" for SubGraph
import "blueprint.nodes.merge" for Merge
import "blueprint.nodes.commentary" for Commentary
import "blueprint.nodes.viewport" for Viewport
import "blueprint.nodes.proxy" for Proxy

class Editor
{
	load()
	{
		this.scene_stack = SceneStack()

		this.camera = tt_Camera2D()

		this.nodes_op = BlueprintEditOP(this.camera, this.scene_stack, this.popup_cb)
		this.preview_op = NodeOP(this.scene_stack)
		this.editop = this.nodes_op

		this.popup_pos = nil
		this.prev_pin = nil

		this.gui_top = Context.init()
		this.gui_nodes = Context.init()

		this.right_press_pos = nil

//		this.filepath = ""
//		this.filepath = "samples/rendergraph/terrain/splatmap.ves"
//		this.filepath = "samples/rendergraph/nodes/compute.ves"
		this.filepath = "samples/terraingraph/nodes/combiner.ves"

		this.hide_nodes = false

		this.popup_nodes = []
		this.all_nodes = {}
		for (var node in [ Number, Number2, Number3, Number4, Combine, Time, Sin, Cos, Radians, Add, Subtract, Multiply, Divide, Matrix, Translate, Rotate, Scale, Camera2D, Camera3D, Perspective, Orthographic, LookAt, For, Array, Print, Clamp, Fetch, Custom, Input, Output, Property, SubGraph, Merge, Commentary, Viewport, Proxy ]) {
			this.add_popup_node(node)
		}

		this.script_stack = []

		// copy and paste
		this.clipboard = ""
		this.cam_pos_on_copy = nil

		NODE_CACHE.set_editor(this)

		var tb = Textbox()
		tb.width = 500
		tb.height = 50
		tb.font_size = 48
		tb.font_color = [196, 64, 64, 255]
		tb.align_hori = 2
		tb.align_vert = 1
		this.TB_TITLE = tb
	}

	update()
	{
		var scene = this.scene_stack.top()
		scene.update()

		// update aabb
		for (var node in scene.nodes) 
		{
			var bp_node = node.components["bp"]
			if (bp_node.aabb_dirty) {
				node.components["bounding"].set_size(bp_node.get_size())
				bp_node.aabb_dirty = false
			}
		}	

		GUI.update(this.gui_top)
		GUI.update(this.gui_nodes)
	}

	draw()
	{
		this.draw_preview()

		if (!this.hide_nodes) {
			this.draw_scene()
		} else {
			// draw op title
			var node = this.preview_op.get_selected()
			if (node) {
				var x = -Graphics.get_width() * 0.5 + 200
				var y = Graphics.get_height() * 0.5 - 50
				Graphics.draw_text(node.name, x, y, 1.0, this.TB_TITLE)
			}
		}

		this.editop.draw()

		Graphics.flush()

		this.draw_gui()

		//Graphics.dtex_debug_draw()
	}

	sizechanged(w, h)
	{
		Graphics.on_size(w, h)
		GUI.on_size(w, h)
		this.camera.on_size(w, h)
	}

	keypressed(key)
	{
		this.editop.on_key_pressed(key)		

		if (key == "delete") 
		{
			this.scene_stack.bp_dirty = true
			GUI.rebuild(this.gui_nodes)
		} 
		else if (key == "space") 
		{
			this.hide_nodes = !this.hide_nodes
			if (this.hide_nodes) {
				this.editop = this.preview_op
			} else {
				this.editop = this.nodes_op
			}
		}
	}

	keyreleased(key)
	{
		this.editop.on_key_released(key)		
	}

	mousemoved(x, y, btn)
	{
		GUI.mouse_input(this.gui_top, btn, MOUSE_MOVE, x, y, 0, 0, 1)
		GUI.mouse_input(this.gui_nodes, btn, MOUSE_MOVE, x, y, -this.camera.pos.x, -this.camera.pos.y, 1.0/this.camera.scale)

		if (!this.is_gui_active()) {
			this.editop.on_mouse_moved(x, y, btn)
		}
	}

	mousedragged(x, y, btn)
	{
		GUI.mouse_input(this.gui_top, btn, MOUSE_DRAG, x, y, 0, 0, 1)
		GUI.mouse_input(this.gui_nodes, btn, MOUSE_DRAG, x, y, -this.camera.pos.x, -this.camera.pos.y, 1.0/this.camera.scale)

		if (!this.is_gui_active()) {
			this.editop.on_mouse_dragged(x, y, btn)
		}
	}

	mousepressed(x, y, btn)
	{
		GUI.mouse_input(this.gui_top, btn, MOUSE_DOWN, x, y, 0, 0, 1)
		GUI.mouse_input(this.gui_nodes, btn, MOUSE_DOWN, x, y, -this.camera.pos.x, -this.camera.pos.y, 1.0/this.camera.scale)

		if (btn == MOUSE_RIGHT) {
			this.right_press_pos = Vector2(x, y)
		}

		if (!this.is_gui_active()) {
			this.editop.on_mouse_pressed(x, y, btn)
		}
	}

	mousereleased(x, y, btn)
	{
		GUI.mouse_input(this.gui_top, btn, MOUSE_UP, x, y, 0, 0, 1)
		GUI.mouse_input(this.gui_nodes, btn, MOUSE_UP, x, y, -this.camera.pos.x, -this.camera.pos.y, 1.0/this.camera.scale)

		if (btn == MOUSE_RIGHT and this.right_press_pos.x == x and this.right_press_pos.y == y) {
			this.right_press_pos = nil
			this.popup_pos = Vector2(x, y)
		} else if (btn == MOUSE_LEFT) {
			this.popup_pos = nil
			this.prev_pin = nil
		}

		if (!this.is_gui_active()) {
			this.editop.on_mouse_released(x, y, btn)
		}
	}

	mouseclicked(x, y, btn)
	{
		this.enter_subgraph()
	}

	mousescrolled(x, y, dx, dy)
	{
		this.editop.on_mouse_scrolled(x, y, dx, dy)
	}

	draw_scene()
	{
		var cam_mt = Matrix44.init()
		var s = 1.0 / this.camera.scale
		cam_mt.translate(-this.camera.pos.x, -this.camera.pos.y, 0)
		cam_mt.scale(s, s, 1)

		var scene = this.scene_stack.top()
		scene.draw(cam_mt)

		// fixme
		Graphics.flush()

		GUI.begin(this.gui_nodes)
		var dirty = false
		for (var node in scene.nodes) {
			var bp_node = node.components["bp"]
			if (bp_node.draw_gui(this.gui_nodes)) {
				dirty = true
			}
		}
		GUI.end(this.gui_nodes)

		if (dirty) {
			this.editop.clear()
		}
	}

	draw_scenes_nav_bar()
	{
		if (this.scene_stack.count() <= 1) {
			return
		}

		var x = - Graphics.get_width() * 0.5 + 20
		var y = Graphics.get_height() * 0.5 - 30
		for (var i in 0..this.scene_stack.scenes.count - 1) 
		{
			var scene = this.scene_stack.scenes[i]
			if (GUI.button(this.gui_top, scene.name, x, y, 0, 0)) 
			{
				while (this.scene_stack.scenes.count > i + 1) {
					this.scene_stack.pop()
					this.filepath = this.scene_stack.top().filepath
				}
				return
			}
			x = x + 50
		}
	}

	draw_gui()
	{
		Graphics.on_cam_update(0, 0, 1)

		GUI.begin(this.gui_top)

		if (this.popup_pos)
		{
			var pos = GUI.trans_scr_pos_to_proj(this.popup_pos.x, this.popup_pos.y, 0, 0, 1)
			var new_node = this.draw_popup(pos[0], pos[1] - 25, this.prev_pin)
			if (new_node)
			{
				var pos = GUI.trans_scr_pos_to_proj(this.popup_pos.x, this.popup_pos.y, -this.camera.pos.x, -this.camera.pos.y, 1.0/this.camera.scale)
				this.add_node(new_node, pos[0], pos[1])
				if (this.prev_pin)
				{
					if (this.prev_pin.is_input) {
						if (!new_node.exports.isEmpty) {
							Blueprint.connect(new_node.exports[0], this.prev_pin)
							this.scene_stack.bp_dirty = true
						}
					} else {
						if (!new_node.imports.isEmpty) {
							Blueprint.connect(this.prev_pin, new_node.imports[0])
							this.scene_stack.bp_dirty = true
						}
					}
				}
				this.popup_pos = nil
				this.prev_pin = nil
			}
		}

		this.draw_scenes_nav_bar()

		// fixme:
		GUI.button(this.gui_top, ".", 9999, 9999, 0, 0)

		GUI.end(this.gui_top)

		Graphics.on_cam_update(this.camera.pos.x, this.camera.pos.y, this.camera.scale)
	}

	is_var_type_match(pin, node)
	{
		var types = []
		if (pin.type is List) {
			for (var type in pin.type) {
				types.add(type)
			}
		} else {
			types.add(pin.type)
		}
		if (types.contains(VAR_TYPE_ANY)) {
			return true
		}

		var pins
		if (pin.is_input) {
			pins = node.exports
		} else {
			pins = node.imports
		}	
		for (var p in pins) 
		{
			if (p.type == VAR_TYPE_ANY) {
				return true
			}
			if (p.type is List) {
				for (var type in p.type) {
					if (types.contains(type)) {
						return true
					}				
				}
			} else {
				if (types.contains(p.type)) {
					return true
				}
			}
		}

		return false
	}	

	draw_popup(x, y, prev_pin)
	{
		var num = 0
		if (prev_pin)
		{
			for (var node in this.popup_nodes) {
				if (this.is_var_type_match(prev_pin, this.all_nodes[node.name])) {
					num = num + 1
				}
			}
		}
		else
		{
			num = this.popup_nodes.count
		}

		var ITEM_WIDTH = 120
		var ITEM_HEIGHT = 25
		GUI.frame(this.gui_top, x, y - ITEM_HEIGHT * (num - 1), ITEM_WIDTH, ITEM_HEIGHT * num)

		for (var node in this.popup_nodes) 
		{
			var show = true
			if (prev_pin) {
				show = this.is_var_type_match(prev_pin, this.all_nodes[node.name])
			}
			if (show) {
				if (GUI.selectable(this.gui_top, node.name, false, x, y, ITEM_WIDTH)) {
					return node()
				}
				y = y - ITEM_HEIGHT
			}
		}
		return nil
	}

	popup_cb(x, y, prev_pin)
	{
		this.popup_pos = Vector2(x, y)
		if (prev_pin) {
			this.prev_pin = prev_pin
		}
	}

	add_popup_node(node)
	{
		this.popup_nodes.add(node)
		this.all_nodes[node.name] = node()
	}

	is_gui_active()
	{
		return this.popup_pos != nil
	}

	add_node(bp_node, x, y)
	{
		var node = SceneNode()

		node.components["bp"] = bp_node

		var pos = Vector2(x, y)

		var bb = BoundingBox2(bp_node.get_size())
		bb.transform(pos, 0, Vector2())
		node.components["bounding"] = bb
		bp_node.aabb_dirty = false

		var trans = Transform2()
		trans.set_position(pos)
		node.components["transform"] = trans

		this.scene_stack.top().add(node)

		return node
	}

	load_file_imports()
	{
		return "
import \"blueprint.blueprint\" for Blueprint
import \"blueprint.nodes.number\" for Number
import \"blueprint.nodes.number2\" for Number2
import \"blueprint.nodes.number3\" for Number3
import \"blueprint.nodes.number4\" for Number4
import \"blueprint.nodes.combine\" for Combine
import \"blueprint.nodes.time\" for Time
import \"blueprint.nodes.sin\" for Sin
import \"blueprint.nodes.cos\" for Cos
import \"blueprint.nodes.radians\" for Radians
import \"blueprint.nodes.add\" for Add
import \"blueprint.nodes.subtract\" for Subtract
import \"blueprint.nodes.multiply\" for Multiply
import \"blueprint.nodes.divide\" for Divide
import \"blueprint.nodes.matrix\" for Matrix
import \"blueprint.nodes.translate\" for Translate
import \"blueprint.nodes.rotate\" for Rotate
import \"blueprint.nodes.scale\" for Scale
import \"blueprint.nodes.camera2d\" for Camera2D
import \"blueprint.nodes.camera3d\" for Camera3D
import \"blueprint.nodes.perspective\" for Perspective
import \"blueprint.nodes.orthographic\" for Orthographic
import \"blueprint.nodes.lookat\" for LookAt
import \"blueprint.nodes.for\" for For
import \"blueprint.nodes.array\" for Array
import \"blueprint.nodes.print\" for Print
import \"blueprint.nodes.clamp\" for Clamp
import \"blueprint.nodes.fetch\" for Fetch
import \"blueprint.nodes.custom\" for Custom
import \"blueprint.nodes.input\" for Input
import \"blueprint.nodes.output\" for Output
import \"blueprint.nodes.property\" for Property
import \"blueprint.nodes.subgraph\" for SubGraph
import \"blueprint.nodes.merge\" for Merge
import \"blueprint.nodes.commentary\" for Commentary
import \"blueprint.nodes.viewport\" for Viewport
import \"blueprint.nodes.proxy\" for Proxy
"
	}

	loadfromfile(filepath)
	{
		this.clear()

		if (filepath != "") {
			this.filepath = filepath
		}
		if (this.filepath == "") {
			return
		}

		var header = "
import \"editor\" for _editor
"
		header = header + this.load_file_imports()

		Filesystem.set_asset_base_dir(Filesystem.get_file_dir(this.filepath))
		var file = IO.open(this.filepath, "r")
		var source = header + file.read()
		IO.close(file)

		Basic.loadstring("temp", source)

		this.nodes_op.comm_op.rebuild()

		this.scene_stack.bp_dirty = true

		this.scene_stack.set_root_filepath(this.filepath)
	}

	savetofile()
	{
		Filesystem.set_asset_base_dir(Filesystem.get_file_dir(this.filepath))
		var file = IO.open(this.filepath, "w")

		var scene = this.scene_stack.top()

		// nodes
		var index = 0
		for (var node in scene.nodes) 
		{
			var bp = node.components["bp"]
			var trans = node.components["transform"]

			var name = "node%(index)"

			file.write("var %(name) = %(bp.name)()\n")

			var node_str = bp.to_string(name)
			file.write("%(node_str)\n")

			file.write("_editor.add_node(node%(index), %(trans.position.x), %(trans.position.y))\n\n")

			index = index + 1
		}

		// connections
		var f_idx = 0
		for (var f_node in scene.nodes) 
		{
			var f_name = "node%(f_idx)"

			var f_bp = f_node.components["bp"]
			for (var f_pin in f_bp.exports)
			{
				for (var f_conn in f_pin.conns)
				{
					if (!f_conn.to.node.dummy)
					{
						var t_pin
						var t_name
						for (var t_idx = 0; t_idx < scene.nodes.count; t_idx = t_idx + 1) {
							var t_bp = scene.nodes[t_idx].components["bp"]
							if (t_bp == f_conn.to.node) {
								t_name = "node%(t_idx)"
							}
						}
						//file.write("Blueprint.connect(%(f_name).exports[%(f_conn.from.slot_idx)], %(t_name).imports[%(f_conn.to.slot_idx)])\n")
						file.write("Blueprint.connect(%(f_name), \"%(f_conn.from.name)\", %(t_name), \"%(f_conn.to.name)\")\n")
					}
				}
			}

			f_idx = f_idx + 1
		}
			
		IO.close(file)
	}

	copy_to_clipboard()
	{
		this.clipboard = ""
		var ext_clipboard = ""

		var scene = this.scene_stack.top()

		// nodes
		var index = 0	
		for (var node in scene.selection) 
		{
			var bp = node.components["bp"]
			var trans = node.components["transform"]

			var name = "node%(index)"
			var source = "
var %(name) = %(bp.name)()
%(bp.to_string(name))
_editor.scene_stack.top().selection.add(_editor.add_node(%(name), %(trans.position.x), %(trans.position.y)))
"
			this.clipboard = this.clipboard + source
			ext_clipboard = ext_clipboard + source

			index = index + 1
		}

		// connections
		var t_idx = 0
		for (var t_node in scene.selection) 
		{
			var t_name = "node%(t_idx)"

			var t_bp = t_node.components["bp"]
			for (var t_pin in t_bp.imports)
			{
				for (var t_conn in t_pin.conns)
				{
					var f_name = nil
					// find in selection
					var f_idx = 0
					for (var node in scene.selection) {
						var f_bp = node.components["bp"]
						if (f_bp == t_conn.from.node) {
							f_name = "node%(f_idx)"
						}
						f_idx = f_idx + 1
					}
					if (f_name) {
						ext_clipboard = ext_clipboard + "Blueprint.connect(%(f_name), \"%(t_conn.from.name)\", %(t_name), \"%(t_conn.to.name)\")\n"	
					}
					
					// find in scene
					if (!f_name)
					{
						for (var f_idx = 0; f_idx < scene.nodes.count; f_idx = f_idx + 1) {
							var f_bp = scene.nodes[f_idx].components["bp"]
							if (f_bp == t_conn.from.node) {
								f_name = "_editor.scene_stack.top().nodes[%(f_idx)].components[\"bp\"]"
							}
						}
					}
					if (f_name) {
						this.clipboard = this.clipboard + "Blueprint.connect(%(f_name), \"%(t_conn.from.name)\", %(t_name), \"%(t_conn.to.name)\")\n"
					}
				}
			}

			t_idx = t_idx + 1
		}

		this.cam_pos_on_copy = Vector2(this.camera.pos.x, this.camera.pos.y)

		tt_System.set_clipboard_text(ext_clipboard)
	}

	paste_from_clipboard()
	{
		var text = this.clipboard
		if (text == "") {
			text = tt_System.get_clipboard_text()
		}
		if (text == "") {
			return
		}

		var scene = this.scene_stack.top()

		scene.selection.clear()

		var header = "
import \"editor\" for _editor
"
		header = header + this.load_file_imports()

		var source = header + text
		Basic.loadstring("temp", source)

		if (this.cam_pos_on_copy)
		{
			var dx = this.camera.pos.x - this.cam_pos_on_copy.x
			var dy = this.camera.pos.y - this.cam_pos_on_copy.y
			var trans_op = Node2dTranslate(this.camera, this.scene_stack)
			trans_op.translate(Vector2(dx, dy))
		}

		this.scene_stack.bp_dirty = true
	}

	refresh()
	{
		this.loadfromfile(this.filepath)
	}

	clear()
	{
		this.editop.clear()
		this.scene_stack.top().clear()

		this.script_stack = []

		this.clipboard = ""
		this.cam_pos_on_copy = nil
	}

	print_screen()
	{
		var TEX_SIZE = 512

		var img_path = this.filepath.replace(".ves", ".jpg")

		var fbo = Framebuffer.init()

		var rbo_color = RenderBuffer.init(TEX_SIZE, TEX_SIZE, "rgb")
		fbo.attach_rbo(rbo_color, "col0")

		var rbo_depth = RenderBuffer.init(TEX_SIZE, TEX_SIZE, "depth_component")
		fbo.attach_rbo(rbo_depth, "depth")

		var prev_fbo = Render.get_fbo(Framebuffer)
		var prev_vp = Render.get_viewport()

		Render.set_fbo(fbo)
		Render.set_viewport([ 0, 0, TEX_SIZE, TEX_SIZE ])

		this.draw_preview()

		var img = ImageData.init("SCREEN_CAPTURE")
		img.store_to_file(img_path)

		Render.set_fbo(prev_fbo)
		Render.set_viewport(prev_vp)
	}

	enter_subgraph()
	{
		var scene = this.scene_stack.top()

		if (scene.selection.count != 1) {
			return false
		}

		var node = scene.selection.front()
		var bp_node = node.components["bp"]
		if (!(bp_node is SubGraph)) {
			return false
		}

		var name = Filesystem.get_filename(bp_node.filepath)
		var next_scene = Scene(name)
		next_scene.filepath = bp_node.filepath
		this.scene_stack.push(next_scene)
		this.loadfromfile(bp_node.filepath)

		return true
	}
}