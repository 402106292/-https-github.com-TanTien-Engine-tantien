import "scene.scene" for Scene
import "graphics.camera2d" for Camera2D as tt_Camera2D
import "gui" for GUI, Context, MOUSE_LEFT, MOUSE_RIGHT, MOUSE_DOWN, MOUSE_UP, MOUSE_MOVE, MOUSE_DRAG
import "blueprint.edit_op" for EditOP as BlueprintEditOP
import "blueprint.node_op" for NodeOP
import "blueprint.blueprint" for Blueprint
import "blueprint.variant" for VAR_TYPE_ANY
import "maths.vector" for Vector2
import "graphics" for Graphics
import "scene.node" for Node as SceneNode
import "scene.components.boundingbox2" for BoundingBox2
import "scene.components.transform2" for Transform2
import "io" for IO
import "filesystem" for Filesystem
import "editgraph.operators.node2d_translate" for Node2dTranslate
import "editor.node_cache" for NODE_CACHE

import "blueprint.nodes.number" for Number
import "blueprint.nodes.number2" for Number2
import "blueprint.nodes.number3" for Number3
import "blueprint.nodes.combine" for Combine
import "blueprint.nodes.time" for Time
import "blueprint.nodes.sin" for Sin
import "blueprint.nodes.cos" for Cos
import "blueprint.nodes.radians" for Radians
import "blueprint.nodes.add" for Add
import "blueprint.nodes.subtract" for Subtract
import "blueprint.nodes.multiply" for Multiply
import "blueprint.nodes.divide" for Divide
import "blueprint.nodes.matrix" for Matrix
import "blueprint.nodes.translate" for Translate
import "blueprint.nodes.rotate" for Rotate
import "blueprint.nodes.scale" for Scale
import "blueprint.nodes.camera2d" for Camera2D
import "blueprint.nodes.camera3d" for Camera3D
import "blueprint.nodes.perspective" for Perspective
import "blueprint.nodes.orthographic" for Orthographic
import "blueprint.nodes.lookat" for LookAt
import "blueprint.nodes.for" for For
import "blueprint.nodes.array" for Array
import "blueprint.nodes.print" for Print
import "blueprint.nodes.clamp" for Clamp
import "blueprint.nodes.fetch" for Fetch
import "blueprint.nodes.custom" for Custom
import "blueprint.nodes.input" for Input
import "blueprint.nodes.output" for Output
import "blueprint.nodes.property" for Property
import "blueprint.nodes.subgraph" for SubGraph

class Editor
{
	load()
	{
		this.scene = Scene()
		this.camera = tt_Camera2D()

		this.nodes_op = BlueprintEditOP(this.camera, this.scene, this.popupCB)
		this.preview_op = NodeOP(this.scene)
		this.editop = this.nodes_op

		this.popup_pos = nil
		this.prev_pin = nil

		this.gui_top = Context.init()
		this.gui_nodes = Context.init()

		this.right_press_pos = nil

//		this.filepath = ""
//		this.filepath = "samples/rendergraph/learnopengl/6.pbr__2.1.2.ibl_irradiance.ves"
//		this.filepath = "assets/rendergraph/equirectangular_to_cubemap.ves"
//		this.filepath = "assets/rendergraph/cubemap_preview.ves"
		this.filepath = "samples/rendergraph/default/cubemap_project_to_2d.ves"

		this.hide_nodes = false

		this.popup_nodes = []
		this.all_nodes = {}
		for (var node in [ Number, Number2, Number3, Combine, Time, Sin, Cos, Radians, Add, Subtract, Multiply, Divide, Matrix, Translate, Rotate, Scale, Camera2D, Camera3D, Perspective, Orthographic, LookAt, For, Array, Print, Clamp, Fetch, Custom, Input, Output, Property, SubGraph ]) {
			this.add_popup_node(node)
		}

		this.script_stack = []

		// copy and paste
		this.clipboard = ""
		this.cam_pos_on_copy = nil

		NODE_CACHE.set_editor(this)
	}

	update()
	{
		this.scene.update()

		// update aabb
		for (var node in this.scene.nodes) 
		{
			var bp_node = node.components["bp"]
			if (bp_node.aabb_dirty) {
				node.components["bounding"].set_size(bp_node.get_size())
				bp_node.aabb_dirty = false
			}
		}	

		GUI.update(this.gui_top)
		GUI.update(this.gui_nodes)
	}

	draw()
	{
		this.drawPreview()

		if (!this.hide_nodes) {
			this.drawScene()		
		}

		this.editop.draw()

		Graphics.flush()

		this.drawGUI()

		//Graphics.dtexDebugDraw()
	}

	sizechanged(w, h)
	{
		Graphics.onSize(w, h)
		GUI.onSize(w, h)
		this.camera.on_size(w, h)
	}

	keypressed(key)
	{
		this.editop.on_key_pressed(key)		

		if (key == "delete") 
		{
			this.scene.bp_dirty = true
			GUI.rebuild(this.gui_nodes)
		} 
		else if (key == "space") 
		{
			this.hide_nodes = !this.hide_nodes
			if (this.hide_nodes) {
				this.editop = this.preview_op
			} else {
				this.editop = this.nodes_op			
			}
		}
	}

	keyreleased(key)
	{
		this.editop.on_key_released(key)		
	}

	mousemoved(x, y, btn)
	{
		GUI.mouseInput(this.gui_top, btn, MOUSE_MOVE, x, y, 0, 0, 1)
		GUI.mouseInput(this.gui_nodes, btn, MOUSE_MOVE, x, y, -this.camera.pos.x, -this.camera.pos.y, 1.0/this.camera.scale)

		if (!this.is_gui_active()) {
			this.editop.on_mouse_moved(x, y, btn)
		}
	}

	mousedragged(x, y, btn)
	{
		GUI.mouseInput(this.gui_top, btn, MOUSE_DRAG, x, y, 0, 0, 1)
		GUI.mouseInput(this.gui_nodes, btn, MOUSE_DRAG, x, y, -this.camera.pos.x, -this.camera.pos.y, 1.0/this.camera.scale)

		if (!this.is_gui_active()) {
			this.editop.on_mouse_dragged(x, y, btn)
		}
	}

	mousepressed(x, y, btn)
	{
		GUI.mouseInput(this.gui_top, btn, MOUSE_DOWN, x, y, 0, 0, 1)
		GUI.mouseInput(this.gui_nodes, btn, MOUSE_DOWN, x, y, -this.camera.pos.x, -this.camera.pos.y, 1.0/this.camera.scale)

		if (btn == MOUSE_RIGHT) {
			this.right_press_pos = Vector2(x, y)
		}

		if (!this.is_gui_active()) {
			this.editop.on_mouse_pressed(x, y, btn)
		}
	}

	mousereleased(x, y, btn)
	{
		GUI.mouseInput(this.gui_top, btn, MOUSE_UP, x, y, 0, 0, 1)
		GUI.mouseInput(this.gui_nodes, btn, MOUSE_UP, x, y, -this.camera.pos.x, -this.camera.pos.y, 1.0/this.camera.scale)

		if (btn == MOUSE_RIGHT and this.right_press_pos.x == x and this.right_press_pos.y == y) {
			this.right_press_pos = nil
			this.popup_pos = Vector2(x, y)
		} else if (btn == MOUSE_LEFT) {
			this.popup_pos = nil
			this.prev_pin = nil
		}

		if (!this.is_gui_active()) {
			this.editop.on_mouse_released(x, y, btn)
		}
	}

	mousescrolled(x, y, dx, dy)
	{
		this.editop.on_mouse_scrolled(x, y, dx, dy)		
	}

	drawScene()
	{
		this.scene.draw()

		// fixme
		Graphics.flush()

		GUI.begin(this.gui_nodes)
		var dirty = false
		for (var node in this.scene.nodes) {
			var bp_node = node.components["bp"]
			if (bp_node.drawGUI(this.gui_nodes)) {
				dirty = true
			}
		}
		GUI.end(this.gui_nodes)

		if (dirty) {
			this.editop.clear()
		}
	}

	drawGUI()
	{
		Graphics.onCamUpdate(0, 0, 1)

		GUI.begin(this.gui_top)

		if (this.popup_pos)
		{
			var pos = GUI.transScrPosToProj(this.popup_pos.x, this.popup_pos.y, 0, 0, 1)
			var new_node = this.drawPopup(pos[0], pos[1] - 25, this.prev_pin)
			if (new_node)
			{
				var pos = GUI.transScrPosToProj(this.popup_pos.x, this.popup_pos.y, -this.camera.pos.x, -this.camera.pos.y, 1.0/this.camera.scale)
				this.add_node(new_node, pos[0], pos[1])
				if (this.prev_pin)
				{
					if (this.prev_pin.is_input) {
						if (!new_node.exports.isEmpty) {
							Blueprint.connect(new_node.exports[0], this.prev_pin)
							this.scene.bp_dirty = true
						}
					} else {
						if (!new_node.imports.isEmpty) {
							Blueprint.connect(this.prev_pin, new_node.imports[0])
							this.scene.bp_dirty = true
						}
					}
				}
				this.popup_pos = nil
				this.prev_pin = nil
			}
		}

		// fixme:
		GUI.button(this.gui_top, ".", 9999, 9999, 0, 0)

		GUI.end(this.gui_top)

		Graphics.onCamUpdate(this.camera.pos.x, this.camera.pos.y, this.camera.scale)
	}

	is_var_type_match(pin, node)
	{
		if (pin.is_input) {
			for (var p in node.exports) {
				if (p.type == pin.type or pin.type == VAR_TYPE_ANY or p.type == VAR_TYPE_ANY) {
					return true
				}
			}
		} else {
			for (var p in node.imports) {
				if (p.type == pin.type or pin.type == VAR_TYPE_ANY or p.type == VAR_TYPE_ANY) {
					return true
				}
			}
		}
		return false
	}	

	drawPopup(x, y, prev_pin)
	{
		var num = 0
		if (prev_pin)
		{
			for (var node in this.popup_nodes) {
				if (this.is_var_type_match(prev_pin, this.all_nodes[node.name])) {
					num = num + 1
				}
			}
		}
		else
		{
			num = this.popup_nodes.count
		}

		var ITEM_WIDTH = 120
		var ITEM_HEIGHT = 25
		GUI.frame(this.gui_top, x, y - ITEM_HEIGHT * (num - 1), ITEM_WIDTH, ITEM_HEIGHT * num)

		for (var node in this.popup_nodes) 
		{
			var show = true
			if (prev_pin) {
				show = this.is_var_type_match(prev_pin, this.all_nodes[node.name])
			}
			if (show) {
				if (GUI.selectable(this.gui_top, node.name, false, x, y, ITEM_WIDTH)) {
					return node()
				}
				y = y - ITEM_HEIGHT
			}
		}
		return nil
	}

	popupCB(x, y, prev_pin)
	{
		this.popup_pos = Vector2(x, y)
		if (prev_pin) {
			this.prev_pin = prev_pin
		}
	}

	add_popup_node(node)
	{
		this.popup_nodes.add(node)
		this.all_nodes[node.name] = node()
	}

	is_gui_active()
	{
		return this.popup_pos != nil
	}

	add_node(bp_node, x, y)
	{
		var node = SceneNode()

		node.components["bp"] = bp_node

		var pos = Vector2(x, y)

		var bb = BoundingBox2(bp_node.get_size())
		bb.transform(pos, 0, Vector2())
		node.components["bounding"] = bb
		bp_node.aabb_dirty = false

		var trans = Transform2()
		trans.set_position(pos)
		node.components["transform"] = trans

		this.scene.add(node)

		return node
	}

	load_file_imports()
	{
		return "
import \"blueprint.blueprint\" for Blueprint
import \"blueprint.nodes.number\" for Number
import \"blueprint.nodes.number2\" for Number2
import \"blueprint.nodes.number3\" for Number3
import \"blueprint.nodes.combine\" for Combine
import \"blueprint.nodes.time\" for Time
import \"blueprint.nodes.sin\" for Sin
import \"blueprint.nodes.cos\" for Cos
import \"blueprint.nodes.radians\" for Radians
import \"blueprint.nodes.add\" for Add
import \"blueprint.nodes.subtract\" for Subtract
import \"blueprint.nodes.multiply\" for Multiply
import \"blueprint.nodes.divide\" for Divide
import \"blueprint.nodes.matrix\" for Matrix
import \"blueprint.nodes.translate\" for Translate
import \"blueprint.nodes.rotate\" for Rotate
import \"blueprint.nodes.scale\" for Scale
import \"blueprint.nodes.camera2d\" for Camera2D
import \"blueprint.nodes.camera3d\" for Camera3D
import \"blueprint.nodes.perspective\" for Perspective
import \"blueprint.nodes.orthographic\" for Orthographic
import \"blueprint.nodes.lookat\" for LookAt
import \"blueprint.nodes.for\" for For
import \"blueprint.nodes.array\" for Array
import \"blueprint.nodes.print\" for Print
import \"blueprint.nodes.clamp\" for Clamp
import \"blueprint.nodes.fetch\" for Fetch
import \"blueprint.nodes.custom\" for Custom
import \"blueprint.nodes.input\" for Input
import \"blueprint.nodes.output\" for Output
import \"blueprint.nodes.property\" for Property
import \"blueprint.nodes.subgraph\" for SubGraph
"	
	}

	loadfromfile(filepath)
	{
		this.clear()

		if (filepath != "") {
			this.filepath = filepath
		}
		if (this.filepath == "") {
			return
		}

		var header = "
import \"editor\" for _editor
"
		header = header + this.load_file_imports()

		Filesystem.setAssetBaseDir(this.filepath)
		var file = IO.open(this.filepath, "r")
		var source = header + file.read()
		IO.close(file)

		Basic.loadstring("temp", source)

		this.scene.bp_dirty = true
	}

	savetofile()
	{
		Filesystem.setAssetBaseDir(this.filepath)
		var file = IO.open(this.filepath, "w")

		// nodes
		var index = 0
		for (var node in this.scene.nodes) 
		{
			var bp = node.components["bp"]
			var trans = node.components["transform"]

			var name = "node%(index)"

			file.write("var %(name) = %(bp.name)()\n")

			var node_str = bp.toString(name)
			file.write("%(node_str)\n")

			file.write("_editor.add_node(node%(index), %(trans.position.x), %(trans.position.y))\n\n")

			index = index + 1
		}

		// connections
		var f_idx = 0
		for (var f_node in this.scene.nodes) 
		{
			var f_name = "node%(f_idx)"

			var f_bp = f_node.components["bp"]
			for (var f_pin in f_bp.exports)
			{
				for (var f_conn in f_pin.conns)
				{
					if (!f_conn.to.node.dummy)
					{
						var t_pin
						var t_name
						for (var t_idx = 0; t_idx < this.scene.nodes.count; t_idx = t_idx + 1) {
							var t_bp = this.scene.nodes[t_idx].components["bp"]
							if (t_bp == f_conn.to.node) {
								t_name = "node%(t_idx)"
							}
						}
						file.write("Blueprint.connect(%(f_name).exports[%(f_conn.from.slot_idx)], %(t_name).imports[%(f_conn.to.slot_idx)])\n")
					}
				}
			}

			f_idx = f_idx + 1
		}
			
		IO.close(file)
	}

	copy_to_clipboard()
	{
		this.clipboard = ""

		// nodes
		var index = 0	
		for (var node in this.scene.selection) 
		{
			var bp = node.components["bp"]
			var trans = node.components["transform"]

			var name = "node%(index)"
			this.clipboard = this.clipboard + "
var %(name) = %(bp.name)()
%(bp.toString(name))
_editor.scene.selection.add(_editor.add_node(%(name), %(trans.position.x), %(trans.position.y)))
"
			index = index + 1
		}

		// connections
		var t_idx = 0
		for (var t_node in this.scene.selection) 
		{
			var t_name = "node%(t_idx)"

			var t_bp = t_node.components["bp"]
			for (var t_pin in t_bp.imports)
			{
				for (var t_conn in t_pin.conns)
				{
					var f_name = nil
					// find in selection
					var f_idx = 0
					for (var node in this.scene.selection) {
						var f_bp = node.components["bp"]
						if (f_bp == t_conn.from.node) {
							f_name = "node%(f_idx)"
						}
						f_idx = f_idx + 1
					}
					// find in scene
					if (!f_name)
					{
						for (var f_idx = 0; f_idx < this.scene.nodes.count; f_idx = f_idx + 1) {
							var f_bp = this.scene.nodes[f_idx].components["bp"]
							if (f_bp == t_conn.from.node) {
								f_name = "_editor.scene.nodes[%(f_idx)].components[\"bp\"]"
							}
						}
					}

					if (f_name) {
						this.clipboard = this.clipboard + "Blueprint.connect(%(f_name).exports[%(t_conn.from.slot_idx)], %(t_name).imports[%(t_conn.to.slot_idx)])\n"					
					}
				}
			}

			t_idx = t_idx + 1
		}

		this.cam_pos_on_copy = Vector2(this.camera.pos.x, this.camera.pos.y)
	}

	paste_from_clipboard()
	{
		if (this.clipboard == "") {
			return
		}

		this.scene.selection.clear()

		var header = "
import \"editor\" for _editor
"
		header = header + this.load_file_imports()

		var source = header + this.clipboard
		Basic.loadstring("temp", source)

		var dx = this.camera.pos.x - this.cam_pos_on_copy.x
		var dy = this.camera.pos.y - this.cam_pos_on_copy.y
		var trans_op = Node2dTranslate(this.camera, this.scene)
		trans_op.translate(Vector2(dx, dy))

		this.scene.bp_dirty = true
	}

	refresh()
	{
		this.loadfromfile(this.filepath)
	}

	clear()
	{
		this.editop.clear()
		this.scene.clear()
	}
}